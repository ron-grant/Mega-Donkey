/*  MegaDonkey Library File:  LCDAGM.c    AGM1264 LCD DRIVER     


    Copyright 2007,2008  Mark Sims & Ron Grant


    This file is part of The Megadonkey Software Library.

    The Megadonkey Software Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Megadonkey Software Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
    more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the Megadonkey Software Library. If not, see <http://www.gnu.org/licenses/>.


  

   Graphic LCD Interface Code for AGM Panel
   Mark Sims  Jan 2007
 
   Low Level I/O modified for AVR + some other hacking.. - Ron Grant

   
   Panel Command Interface
   Screen Read/Write
   Character Generator (character bitmap)
   Character Drawing 
   Dot Plotting
   Blts


 This file is included in lcd.c and should not be included in IDE project, but
 instead may be added in the Other Files folder of the IDE.
 If the file is added to the IDE project you will get all kinds of errors.

 ALSO, if editing in IDE -- BE SURE to explicity save the file before 
 recompiling project -- IDE/MakeUtility will not notice if this file included 
 within LCD.C is out of date.

 This .c file does not have an associated header file.


*/


#define EXTERN extern


#define reverse(x) pgm_read_byte_near(&rvs_table[x])



// Atmel AVR
// Low Level Port & Bit Assignments
// FOR Megadonkey (Mega 128/2561 based controller)


// LCD 8 Bit Data Bus

#define DATA_PORT       PORTA      // 8 bit bi-directional data port
#define DATA_PORT_DDR   DDRA       // Data Direction Register for Data Port

#ifdef REVERSE_DB
   #define DATA_PORT_READ  reverse(PINA)
   #define data_out(byte)  DATA_PORT = reverse(byte)
   #define DATA_PORT_BUSY bit_is_set(PINA,0)
#else
   #define DATA_PORT_READ  (PINA)
   #define data_out(byte)  DATA_PORT = (byte)
   #define DATA_PORT_BUSY bit_is_set(PINA,7)
#endif

//  !!! WARNING:  The KS0107 controller uses active high chip selects.
//                All other controllers use active low selects.

// NOP is used when compiling with optimizer on... 
// it is needed to make clock signals compatible with the LCD controller chip specs
#define NOP asm volatile ("nop");  asm volatile ("nop");  asm volatile ("nop");

#define rw_low()     cbi(PORTC,4); DATA_PORT_DDR = 0xFF
#define rw_high()    PORTA=0xFF; DATA_PORT_DDR=0x00; sbi(PORTC,4)
#define cs_low()     cbi(PORTC,5);
#define cs_high()    sbi(PORTC,5);
#define cs2_low()    cbi(PORTC,6);
#define cs2_high()   sbi(PORTC,6);
#define rs_low()     cbi(PORTC,3)
#define rs_high()    sbi(PORTC,3)
#define e_low()      cbi(PORTG,2); NOP; NOP  /* seems to work with e_low stretched, but let's be safe */
#define e_high()     sbi(PORTG,2); NOP; NOP  /* e_high needs to be stretched */
#define clock_e()    e_high(); e_low()
#define reset_low()  cbi(PORTC,7)
#define reset_high() sbi(PORTC,7)

u08 bus_in_use(void)
{
   if(PINC & _BV(5)) return 1;
   else if(PINC & _BV(6)) return 1;
   else return 0;
}


#define DISPLAY_OFF 0x3E
#define DISPLAY_ON  0x3F
#define SET_COL     0x40
#define SET_PAGE    0xB8
#define SET_LINE    0xC0


// --------------------------------------------------------------------------------------

u08 pixel_masks[] = {
   0x01, 0x02, 0x04, 0x08,  0x10, 0x20, 0x40, 0x80
};

u08 cgen[] PROGMEM = {  // row based char gen table
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 00:   
   0x7e, 0x81, 0x95, 0xb1, 0xb1, 0x95, 0x81, 0x7e,   // 01:   
   0x7e, 0xff, 0xeb, 0xcf, 0xcf, 0xeb, 0xff, 0x7e,   // 02:   
   0x0e, 0x1f, 0x3f, 0x7e, 0x3f, 0x1f, 0x0e, 0x00,   // 03:   
   0x08, 0x1c, 0x3e, 0x7f, 0x3e, 0x1c, 0x08, 0x00,   // 04:   
   0x18, 0xba, 0xff, 0xff, 0xff, 0xba, 0x18, 0x00,   // 05:   
   0x10, 0xb8, 0xfc, 0xff, 0xfc, 0xb8, 0x10, 0x00,   // 06:   
   0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,   // 07:   
   0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,   // 08:   
   0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,   // 09:   
   0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,   // 0A:   
   0x70, 0xf8, 0x88, 0x88, 0xfd, 0x7f, 0x07, 0x0f,   // 0B:   
   0x00, 0x4e, 0x5f, 0xf1, 0xf1, 0x5f, 0x4e, 0x00,   // 0C:   
   0xc0, 0xe0, 0xff, 0x7f, 0x05, 0x05, 0x07, 0x07,   // 0D:   
   0xc0, 0xff, 0x7f, 0x05, 0x05, 0x65, 0x7f, 0x3f,   // 0E:   
   0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,   // 0F:   
   0x7f, 0x3e, 0x3e, 0x1c, 0x1c, 0x08, 0x08, 0x00,   // 10:   
   0x08, 0x08, 0x1c, 0x1c, 0x3e, 0x3e, 0x7f, 0x00,   // 11:   
   0x00, 0x24, 0x66, 0xff, 0xff, 0x66, 0x24, 0x00,   // 12:   
   0x00, 0x5f, 0x5f, 0x00, 0x00, 0x5f, 0x5f, 0x00,   // 13:   
   0x06, 0x0f, 0x09, 0x7f, 0x7f, 0x01, 0x7f, 0x7f,   // 14:   
   0x40, 0xda, 0xbf, 0xa5, 0xfd, 0x59, 0x03, 0x02,   // 15:   
   0x00, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x00,   // 16:   
   0x80, 0x94, 0xb6, 0xff, 0xff, 0xb6, 0x94, 0x80,   // 17:   
   0x00, 0x04, 0x06, 0x7f, 0x7f, 0x06, 0x04, 0x00,   // 18:   
   0x00, 0x10, 0x30, 0x7f, 0x7f, 0x30, 0x10, 0x00,   // 19:   
   0x08, 0x08, 0x08, 0x2a, 0x3e, 0x1c, 0x08, 0x00,   // 1A:   
   0x08, 0x1c, 0x3e, 0x2a, 0x08, 0x08, 0x08, 0x00,   // 1B:   
   0x3c, 0x3c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,   // 1C:   
   0x08, 0x1c, 0x3e, 0x08, 0x08, 0x3e, 0x1c, 0x08,   // 1D:   
   0x30, 0x38, 0x3c, 0x3e, 0x3e, 0x3c, 0x38, 0x30,   // 1E:   
   0x06, 0x0e, 0x1e, 0x3e, 0x3e, 0x1e, 0x0e, 0x06,   // 1F:   
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 20:   
   0x00, 0x0e, 0x5f, 0x5f, 0x0e, 0x00, 0x00, 0x00,   // 21:  !
   0x00, 0x07, 0x07, 0x00, 0x07, 0x07, 0x00, 0x00,   // 22:  "
   0x14, 0x7f, 0x7f, 0x14, 0x7f, 0x7f, 0x14, 0x00,   // 23:  #
   0x24, 0x2e, 0x6b, 0x6b, 0x3a, 0x12, 0x00, 0x00,   // 24:  $
   0x46, 0x66, 0x30, 0x18, 0x0c, 0x66, 0x62, 0x00,   // 25:  %
   0x30, 0x7a, 0x4f, 0x5d, 0x37, 0x7a, 0x48, 0x00,   // 26:  &
   0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // 27:  '
   0x00, 0x1c, 0x3e, 0x63, 0x41, 0x00, 0x00, 0x00,   // 28:  (
   0x00, 0x41, 0x63, 0x3e, 0x1c, 0x00, 0x00, 0x00,   // 29:  )
   0x08, 0x2a, 0x3e, 0x1c, 0x1c, 0x3e, 0x2a, 0x08,   // 2A:  *
   0x08, 0x08, 0x3e, 0x3e, 0x08, 0x08, 0x00, 0x00,   // 2B:  +
   0x00, 0x80, 0xe0, 0x60, 0x00, 0x00, 0x00, 0x00,   // 2C:  ,
   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,   // 2D:  -
   0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00,   // 2E:  .
   0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x01, 0x00,   // 2F:  /
   0x3e, 0x7f, 0x71, 0x59, 0x4d, 0x7f, 0x3e, 0x00,   // 30:  0
   0x40, 0x42, 0x7f, 0x7f, 0x40, 0x40, 0x00, 0x00,   // 31:  1
   0x62, 0x73, 0x59, 0x49, 0x6f, 0x66, 0x00, 0x00,   // 32:  2
   0x22, 0x63, 0x49, 0x49, 0x7f, 0x36, 0x00, 0x00,   // 33:  3
   0x18, 0x1c, 0x16, 0x53, 0x7f, 0x7f, 0x50, 0x00,   // 34:  4
   0x27, 0x67, 0x45, 0x45, 0x7d, 0x39, 0x00, 0x00,   // 35:  5
   0x3c, 0x7e, 0x4b, 0x49, 0x79, 0x30, 0x00, 0x00,   // 36:  6
   0x03, 0x03, 0x71, 0x79, 0x0f, 0x07, 0x00, 0x00,   // 37:  7
   0x36, 0x7f, 0x49, 0x49, 0x7f, 0x36, 0x00, 0x00,   // 38:  8
   0x06, 0x4f, 0x49, 0x69, 0x3f, 0x1e, 0x00, 0x00,   // 39:  9
   0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,   // 3A:  :
   0x00, 0x80, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,   // 3B:  ;
   0x08, 0x1c, 0x36, 0x63, 0x41, 0x00, 0x00, 0x00,   // 3C:  <
   0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00,   // 3D:  =
   0x00, 0x41, 0x63, 0x36, 0x1c, 0x08, 0x00, 0x00,   // 3E:  >
   0x02, 0x03, 0x51, 0x59, 0x0f, 0x06, 0x00, 0x00,   // 3F:  ?
   0x3e, 0x7f, 0x41, 0x5d, 0x5d, 0x1f, 0x1e, 0x00,   // 40:  @
   0x7c, 0x7e, 0x13, 0x13, 0x7e, 0x7c, 0x00, 0x00,   // 41:  A
   0x41, 0x7f, 0x7f, 0x49, 0x49, 0x7f, 0x36, 0x00,   // 42:  B
   0x1c, 0x3e, 0x63, 0x41, 0x41, 0x63, 0x22, 0x00,   // 43:  C
   0x41, 0x7f, 0x7f, 0x41, 0x63, 0x3e, 0x1c, 0x00,   // 44:  D
   0x00, 0x7f, 0x7f, 0x49, 0x49, 0x41, 0x41, 0x00,   // 45:  E
   0x00, 0x7f, 0x7f, 0x09, 0x09, 0x01, 0x01, 0x00,   // 46:  F
   0x1c, 0x3e, 0x63, 0x41, 0x51, 0x73, 0x72, 0x00,   // 47:  G
   0x7f, 0x7f, 0x08, 0x08, 0x7f, 0x7f, 0x00, 0x00,   // 48:  H
   0x00, 0x41, 0x7f, 0x7f, 0x41, 0x00, 0x00, 0x00,   // 49:  I
   0x30, 0x70, 0x40, 0x41, 0x7f, 0x3f, 0x01, 0x00,   // 4A:  J
   0x41, 0x7f, 0x7f, 0x08, 0x1c, 0x77, 0x63, 0x00,   // 4B:  K
   0x00, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x00,   // 4C:  L
   0x7f, 0x7f, 0x0e, 0x1c, 0x0e, 0x7f, 0x7f, 0x00,   // 4D:  M
   0x7f, 0x7f, 0x06, 0x0c, 0x18, 0x7f, 0x7f, 0x00,   // 4E:  N
   0x1c, 0x3e, 0x63, 0x41, 0x63, 0x3e, 0x1c, 0x00,   // 4F:  O
   0x41, 0x7f, 0x7f, 0x49, 0x09, 0x0f, 0x06, 0x00,   // 50:  P
   0x1e, 0x3f, 0x21, 0x71, 0x7f, 0x5e, 0x00, 0x00,   // 51:  Q
   0x41, 0x7f, 0x7f, 0x09, 0x19, 0x7f, 0x66, 0x00,   // 52:  R
   0x26, 0x6f, 0x4d, 0x59, 0x73, 0x32, 0x00, 0x00,   // 53:  S
   0x01, 0x01, 0x7f, 0x7f, 0x01, 0x01, 0x00, 0x00,   // 54:  T
   0x7f, 0x7f, 0x40, 0x40, 0x7f, 0x7f, 0x00, 0x00,   // 55:  U
   0x1f, 0x3f, 0x60, 0x60, 0x3f, 0x1f, 0x00, 0x00,   // 56:  V
   0x7f, 0x7f, 0x30, 0x18, 0x30, 0x7f, 0x7f, 0x00,   // 57:  W
   0x43, 0x67, 0x3c, 0x18, 0x3c, 0x67, 0x43, 0x00,   // 58:  X
   0x07, 0x4f, 0x78, 0x78, 0x4f, 0x07, 0x00, 0x00,   // 59:  Y
   0x41, 0x61, 0x71, 0x59, 0x4d, 0x47, 0x43, 0x00,   // 5A:  Z
   0x00, 0x7f, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00,   // 5B:  [
   0x01, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00,   // 5C:  back slash
   0x00, 0x41, 0x41, 0x7f, 0x7f, 0x00, 0x00, 0x00,   // 5D:  ]
   0x08, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x08, 0x00,   // 5E:  ^
   0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,   // 5F:  _
   0x00, 0x00, 0x03, 0x07, 0x04, 0x00, 0x00, 0x00,   // 60:  `
   0x20, 0x74, 0x54, 0x54, 0x3c, 0x78, 0x40, 0x00,   // 61:  a
   0x41, 0x7f, 0x3f, 0x48, 0x48, 0x78, 0x30, 0x00,   // 62:  b
   0x38, 0x7c, 0x44, 0x44, 0x6c, 0x28, 0x00, 0x00,   // 63:  c
   0x30, 0x78, 0x48, 0x49, 0x3f, 0x7f, 0x40, 0x00,   // 64:  d
   0x38, 0x7c, 0x54, 0x54, 0x5c, 0x18, 0x00, 0x00,   // 65:  e
   0x48, 0x7e, 0x7f, 0x49, 0x03, 0x02, 0x00, 0x00,   // 66:  f
   0x98, 0xbc, 0xa4, 0xa4, 0xf8, 0x7c, 0x04, 0x00,   // 67:  g
   0x41, 0x7f, 0x7f, 0x08, 0x04, 0x7c, 0x78, 0x00,   // 68:  h
   0x00, 0x44, 0x7d, 0x7d, 0x40, 0x00, 0x00, 0x00,   // 69:  i
   0x60, 0xe0, 0x80, 0x80, 0xfd, 0x7d, 0x00, 0x00,   // 6A:  j
   0x41, 0x7f, 0x7f, 0x10, 0x38, 0x6c, 0x44, 0x00,   // 6B:  k
   0x00, 0x41, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00,   // 6C:  l
   0x7c, 0x7c, 0x18, 0x38, 0x1c, 0x7c, 0x78, 0x00,   // 6D:  m
   0x7c, 0x7c, 0x04, 0x04, 0x7c, 0x78, 0x00, 0x00,   // 6E:  n
   0x38, 0x7c, 0x44, 0x44, 0x7c, 0x38, 0x00, 0x00,   // 6F:  o
   0x84, 0xfc, 0xf8, 0xa4, 0x24, 0x3c, 0x18, 0x00,   // 70:  p
   0x18, 0x3c, 0x24, 0xa4, 0xf8, 0xfc, 0x84, 0x00,   // 71:  q
   0x44, 0x7c, 0x78, 0x4c, 0x04, 0x1c, 0x18, 0x00,   // 72:  r
   0x48, 0x5c, 0x54, 0x54, 0x74, 0x24, 0x00, 0x00,   // 73:  s
   0x00, 0x04, 0x3e, 0x7f, 0x44, 0x24, 0x00, 0x00,   // 74:  t
   0x3c, 0x7c, 0x40, 0x40, 0x3c, 0x7c, 0x40, 0x00,   // 75:  u
   0x1c, 0x3c, 0x60, 0x60, 0x3c, 0x1c, 0x00, 0x00,   // 76:  v
   0x3c, 0x7c, 0x70, 0x38, 0x70, 0x7c, 0x3c, 0x00,   // 77:  w
   0x44, 0x6c, 0x38, 0x10, 0x38, 0x6c, 0x44, 0x00,   // 78:  x
   0x9c, 0xbc, 0xa0, 0xa0, 0xfc, 0x7c, 0x00, 0x00,   // 79:  y
   0x4c, 0x64, 0x74, 0x5c, 0x4c, 0x64, 0x00, 0x00,   // 7A:  z
   0x08, 0x08, 0x3e, 0x77, 0x41, 0x41, 0x00, 0x00,   // 7B:  {
   0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00,   // 7C:  |
   0x41, 0x41, 0x77, 0x3e, 0x08, 0x08, 0x00, 0x00,   // 7D:  }
   0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00,   // 7E:  ~
   0x70, 0x78, 0x4c, 0x46, 0x4c, 0x78, 0x70, 0x00,   // 7F:  

   0x0e, 0x9f, 0x91, 0x91, 0xb1, 0xfb, 0x4a, 0x00,   // 80:  Ä
   0x3a, 0x7a, 0x40, 0x40, 0x3a, 0x7a, 0x40, 0x00,   // 81:  Å
   0x38, 0x7c, 0x54, 0x55, 0x5d, 0x19, 0x00, 0x00,   // 82:  Ç
   0x02, 0x21, 0x75, 0x55, 0x55, 0x3d, 0x79, 0x42,   // 83:  É
   0x21, 0x75, 0x54, 0x54, 0x3d, 0x79, 0x40, 0x00,   // 84:  Ñ
   0x21, 0x75, 0x55, 0x54, 0x3c, 0x78, 0x40, 0x00,   // 85:  Ö
   0x20, 0x74, 0x57, 0x57, 0x3c, 0x78, 0x40, 0x00,   // 86:  Ü
   0x18, 0x3c, 0xa4, 0xa4, 0xe4, 0x4c, 0x08, 0x00,   // 87:  á
   0x02, 0x39, 0x7d, 0x55, 0x55, 0x5d, 0x19, 0x02,   // 88:  à
   0x39, 0x7d, 0x54, 0x54, 0x5d, 0x19, 0x00, 0x00,   // 89:  â
   0x39, 0x7d, 0x55, 0x54, 0x5c, 0x18, 0x00, 0x00,   // 8A:  ä
   0x01, 0x45, 0x7c, 0x7c, 0x41, 0x01, 0x00, 0x00,   // 8B:  ã
   0x02, 0x01, 0x45, 0x7d, 0x7d, 0x41, 0x02, 0x00,   // 8C:  å
   0x01, 0x45, 0x7d, 0x7c, 0x40, 0x00, 0x00, 0x00,   // 8D:  ç
   0x79, 0x7d, 0x14, 0x16, 0x14, 0x7d, 0x79, 0x00,   // 8E:  é
   0x70, 0x78, 0x2b, 0x2b, 0x78, 0x70, 0x00, 0x00,   // 8F:  è
   0x44, 0x7c, 0x7c, 0x55, 0x55, 0x45, 0x00, 0x00,   // 90:  ê
   0x20, 0x74, 0x54, 0x54, 0x7c, 0x7c, 0x54, 0x54,   // 91:  ë
   0x7c, 0x7e, 0x0b, 0x09, 0x7f, 0x7f, 0x49, 0x00,   // 92:  í
   0x32, 0x79, 0x49, 0x49, 0x79, 0x32, 0x00, 0x00,   // 93:  ì
   0x32, 0x7a, 0x48, 0x48, 0x7a, 0x32, 0x00, 0x00,   // 94:  î
   0x32, 0x7a, 0x4a, 0x48, 0x78, 0x30, 0x00, 0x00,   // 95:  ï
   0x3a, 0x79, 0x41, 0x41, 0x39, 0x7a, 0x40, 0x00,   // 96:  ñ
   0x3a, 0x7a, 0x42, 0x40, 0x38, 0x78, 0x40, 0x00,   // 97:  ó
   0x9a, 0xba, 0xa0, 0xa0, 0xfa, 0x7a, 0x00, 0x00,   // 98:  ò
   0x01, 0x19, 0x3c, 0x66, 0x66, 0x3c, 0x19, 0x01,   // 99:  ô
   0x3d, 0x7d, 0x40, 0x40, 0x7d, 0x3d, 0x00, 0x00,   // 9A:  ö
   0x18, 0x3c, 0x24, 0xe7, 0xe7, 0x24, 0x24, 0x00,   // 9B:  õ
   0x68, 0x7e, 0x7f, 0x49, 0x43, 0x66, 0x20, 0x00,   // 9C:  ú
   0x53, 0x57, 0xfc, 0xfc, 0x57, 0x53, 0x00, 0x00,   // 9D:  ù
   0xff, 0xff, 0x09, 0x09, 0x2f, 0x76, 0xf8, 0xa0,   // 9E:  û
   0x40, 0xc0, 0x88, 0xfe, 0x7f, 0x09, 0x03, 0x02,   // 9F:  ü
   0x20, 0x74, 0x54, 0x55, 0x3d, 0x79, 0x40, 0x00,   // A0:  †
   0x00, 0x44, 0x7d, 0x7d, 0x41, 0x00, 0x00, 0x00,   // A1:  °
   0x30, 0x78, 0x48, 0x4a, 0x7a, 0x32, 0x00, 0x00,   // A2:  ¢
   0x38, 0x78, 0x40, 0x42, 0x3a, 0x7a, 0x40, 0x00,   // A3:  £
   0x7a, 0x72, 0x0a, 0x0a, 0x7a, 0x70, 0x00, 0x00,   // A4:  §
   0x7d, 0x7d, 0x19, 0x31, 0x7d, 0x7d, 0x00, 0x00,   // A5:  •
   0x00, 0x26, 0x2f, 0x29, 0x2f, 0x2f, 0x28, 0x00,   // A6:  ¶
   0x00, 0x26, 0x2f, 0x29, 0x2f, 0x26, 0x00, 0x00,   // A7:  ß
   0x00, 0x20, 0x70, 0x5d, 0x4d, 0x60, 0x20, 0x00,   // A8:  ®
   0x38, 0x38, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,   // A9:  ©
   0x08, 0x08, 0x08, 0x08, 0x38, 0x38, 0x00, 0x00,   // AA:  ™
   0x67, 0x37, 0x18, 0x0c, 0x96, 0xcb, 0xb9, 0x90,   // AB:  ´
   0x4f, 0x6f, 0x30, 0x18, 0x6c, 0x76, 0xdb, 0xf9,   // AC:  ¨
   0x00, 0x00, 0x30, 0x7d, 0x7d, 0x30, 0x00, 0x00,   // AD:  ≠
   0x08, 0x1c, 0x36, 0x22, 0x08, 0x1c, 0x36, 0x22,   // AE:  Æ
   0x22, 0x36, 0x1c, 0x08, 0x22, 0x36, 0x1c, 0x08,   // AF:  Ø
   0xaa, 0x00, 0x55, 0x00, 0xaa, 0x00, 0x55, 0x00,   // B0:  ∞
   0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,   // B1:  ±
   0xd7, 0xff, 0xaa, 0x77, 0xbd, 0xea, 0x7f, 0xdd,   // B2:  ≤
   0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,   // B3:  ≥
   0x10, 0x10, 0x10, 0xff, 0xff, 0x00, 0x00, 0x00,   // B4:  ¥
   0x14, 0x14, 0x14, 0xff, 0xff, 0x00, 0x00, 0x00,   // B5:  µ
   0x10, 0x10, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00,   // B6:  ∂
   0x10, 0x10, 0xf0, 0xf0, 0x10, 0xf0, 0xf0, 0x00,   // B7:  ∑
   0x14, 0x14, 0x14, 0xfc, 0xfc, 0x00, 0x00, 0x00,   // B8:  ∏
   0x14, 0x14, 0xf7, 0xf7, 0x00, 0xff, 0xff, 0x00,   // B9:  π
   0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00,   // BA:  ∫
   0x14, 0x14, 0xf4, 0xf4, 0x04, 0xfc, 0xfc, 0x00,   // BB:  ª
   0x14, 0x14, 0x17, 0x17, 0x10, 0x1f, 0x1f, 0x00,   // BC:  º
   0x10, 0x10, 0x1f, 0x1f, 0x10, 0x1f, 0x1f, 0x00,   // BD:  Ω
   0x14, 0x14, 0x14, 0x1f, 0x1f, 0x00, 0x00, 0x00,   // BE:  æ
   0x10, 0x10, 0x10, 0xf0, 0xf0, 0x00, 0x00, 0x00,   // BF:  ø
   0x00, 0x00, 0x00, 0x1f, 0x1f, 0x10, 0x10, 0x10,   // C0:  ¿
   0x10, 0x10, 0x10, 0x1f, 0x1f, 0x10, 0x10, 0x10,   // C1:  ¡
   0x10, 0x10, 0x10, 0xf0, 0xf0, 0x10, 0x10, 0x10,   // C2:  ¬
   0x00, 0x00, 0x00, 0xff, 0xff, 0x10, 0x10, 0x10,   // C3:  √
   0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,   // C4:  ƒ
   0x10, 0x10, 0x10, 0xff, 0xff, 0x10, 0x10, 0x10,   // C5:  ≈
   0x00, 0x00, 0x00, 0xff, 0xff, 0x14, 0x14, 0x14,   // C6:  ∆
   0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x10,   // C7:  «
   0x00, 0x00, 0x1f, 0x1f, 0x10, 0x17, 0x17, 0x14,   // C8:  »
   0x00, 0x00, 0xfc, 0xfc, 0x04, 0xf4, 0xf4, 0x14,   // C9:  …
   0x14, 0x14, 0x17, 0x17, 0x10, 0x17, 0x17, 0x14,   // CA:   
   0x14, 0x14, 0xf4, 0xf4, 0x04, 0xf4, 0xf4, 0x14,   // CB:  À
   0x00, 0x00, 0xff, 0xff, 0x00, 0xf7, 0xf7, 0x14,   // CC:  Ã
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,   // CD:  Õ
   0x14, 0x14, 0xf7, 0xf7, 0x00, 0xf7, 0xf7, 0x14,   // CE:  Œ
   0x14, 0x14, 0x14, 0x17, 0x17, 0x14, 0x14, 0x14,   // CF:  œ
   0x10, 0x10, 0x1f, 0x1f, 0x10, 0x1f, 0x1f, 0x10,   // D0:  –
   0x14, 0x14, 0x14, 0xf4, 0xf4, 0x14, 0x14, 0x14,   // D1:  —
   0x10, 0x10, 0xf0, 0xf0, 0x10, 0xf0, 0xf0, 0x10,   // D2:  “
   0x00, 0x00, 0x1f, 0x1f, 0x10, 0x1f, 0x1f, 0x10,   // D3:  ”
   0x00, 0x00, 0x00, 0x1f, 0x1f, 0x14, 0x14, 0x14,   // D4:  ‘
   0x00, 0x00, 0x00, 0xfc, 0xfc, 0x14, 0x14, 0x14,   // D5:  ’
   0x00, 0x00, 0xf0, 0xf0, 0x10, 0xf0, 0xf0, 0x10,   // D6:  ÷
   0x10, 0x10, 0xff, 0xff, 0x10, 0xff, 0xff, 0x10,   // D7:  ◊
   0x14, 0x14, 0x14, 0xff, 0xff, 0x14, 0x14, 0x14,   // D8:  ÿ
   0x10, 0x10, 0x10, 0x1f, 0x1f, 0x00, 0x00, 0x00,   // D9:  Ÿ
   0x00, 0x00, 0x00, 0xf0, 0xf0, 0x10, 0x10, 0x10,   // DA:  ⁄
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,   // DB:  €
   0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,   // DC:  ‹
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,   // DD:  ›
   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,   // DE:  ﬁ
   0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,   // DF:  ﬂ
   0x38, 0x7c, 0x44, 0x6c, 0x38, 0x6c, 0x44, 0x00,   // E0:  ‡
   0xfc, 0xfe, 0x2a, 0x2a, 0x3e, 0x14, 0x00, 0x00,   // E1:  ·
   0x7e, 0x7e, 0x02, 0x02, 0x06, 0x06, 0x00, 0x00,   // E2:  ‚
   0x04, 0x7c, 0x7c, 0x04, 0x7c, 0x7c, 0x04, 0x00,   // E3:  „
   0x63, 0x77, 0x5d, 0x49, 0x63, 0x63, 0x00, 0x00,   // E4:  ‰
   0x38, 0x7c, 0x44, 0x7c, 0x3c, 0x04, 0x04, 0x00,   // E5:  Â
   0x80, 0xfe, 0x7e, 0x20, 0x20, 0x3e, 0x1e, 0x00,   // E6:  Ê
   0x04, 0x06, 0x02, 0x7e, 0x7c, 0x06, 0x02, 0x00,   // E7:  Á
   0x99, 0xbd, 0xe7, 0xe7, 0xbd, 0x99, 0x00, 0x00,   // E8:  Ë
   0x1c, 0x3e, 0x6b, 0x49, 0x6b, 0x3e, 0x1c, 0x00,   // E9:  È
   0x4c, 0x7e, 0x73, 0x01, 0x73, 0x7e, 0x4c, 0x00,   // EA:  Í
   0x30, 0x78, 0x4a, 0x4f, 0x7d, 0x39, 0x00, 0x00,   // EB:  Î
   0x18, 0x3c, 0x24, 0x3c, 0x3c, 0x24, 0x3c, 0x18,   // EC:  Ï
   0x98, 0xfc, 0x64, 0x3c, 0x3e, 0x27, 0x3d, 0x18,   // ED:  Ì
   0x1c, 0x3e, 0x6b, 0x49, 0x49, 0x00, 0x00, 0x00,   // EE:  Ó
   0x7e, 0x7f, 0x01, 0x01, 0x7f, 0x7e, 0x00, 0x00,   // EF:  Ô
   0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x00,   // F0:  
   0x00, 0x44, 0x44, 0x5f, 0x5f, 0x44, 0x44, 0x00,   // F1:  Ò
   0x40, 0x51, 0x5b, 0x4e, 0x44, 0x40, 0x00, 0x00,   // F2:  Ú
   0x40, 0x44, 0x4e, 0x5b, 0x51, 0x40, 0x00, 0x00,   // F3:  Û
   0x00, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x07, 0x06,   // F4:  Ù
   0x60, 0xe0, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x00,   // F5:  ı
   0x00, 0x08, 0x08, 0x6b, 0x6b, 0x08, 0x08, 0x00,   // F6:  ˆ
   0x24, 0x36, 0x12, 0x36, 0x24, 0x36, 0x12, 0x00,   // F7:  ˜
   0x00, 0x06, 0x0f, 0x09, 0x0f, 0x06, 0x00, 0x00,   // F8:  ¯
   0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,   // F9:  ˘
   0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00,   // FA:  ˙
   0x10, 0x30, 0x70, 0xc0, 0xff, 0xff, 0x01, 0x01,   // FB:  ˚
   0x00, 0x1f, 0x1e, 0x01, 0x1f, 0x1e, 0x00, 0x00,   // FC:  ¸
   0x12, 0x19, 0x1d, 0x17, 0x12, 0x00, 0x00, 0x00,   // FD:  ˝
   0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00,   // FE:  ˛
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // FF:  ˇ
};

u08 rvs_table[] PROGMEM = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

/* ----------------- LCD controller command routines ----------------- */
#ifdef KS0107

#ifdef INLINE_HW_ACCESS

#define cmd_wait(void)  \
{                       \
u08 i;                  \
                        \
   rs_low();            \
   e_high();            \
   i = 0;               \
   while(DATA_PORT_BUSY && (i++<50));  \
   e_low();             \
}


#define send_command(cmd, data)  \
{                                \
   cmd_wait();                   \
   rw_low();                     \
   data_out((cmd) | (data));     \
   clock_e();                    \
   rw_high();                    \
}

#else

void cmd_wait(void)
{
u08 i;

   rs_low();

   e_high();

   i = 0;
   while(DATA_PORT_BUSY && (i++ < 100));

   e_low();
}


void send_command(u08 cmd, u08 data)
{
   cmd_wait();        // wait for LCD not busy

   rw_low();
   data_out(cmd | data);
   clock_e();         // clock the data byte
   rw_high();
}

#endif


void write_screen(COORD col,COORD row, u08 data)
{  
   /* write screen byte that contains screen coordinate (col, row) */

   cs_high();   // enable both controllers (one per half screen)
   cs2_high();

   send_command(SET_PAGE, row/PAGES);
   send_command(SET_COL, col&0x3F);  //!!!

   if(col >= (COLS/2)) {   // disable one half screen
      cs_low(); 
   }
   else {
      cs2_low();
   }

   cmd_wait();

   rs_high();
   rw_low();
   data_out(data);
   clock_e();
   rw_high();

   cs_low();
   cs2_low();
}

u08 read_screen(COORD col,COORD row)
{  /* get screen byte that contains screen coordinate (col, row) */
u08 c;

   cs_high();   // enable both controllers (one per half screen)
   cs2_high();

   send_command(SET_PAGE, row/PAGES);
   send_command(SET_COL, col&0x3F);  //!!!

   if(col >= (COLS/2)) {   // disable one half screen
      cs_low(); 
   }
   else {
      cs2_low();
   }

   cmd_wait();  //dummy read cycle
   rs_high();
   clock_e();

   cmd_wait();  //real read cycle
   rs_high();
   e_high();
   c = DATA_PORT_READ;
   e_low();

   cs_low();
   cs2_low();
   return c;
}


void set_lcdtop(unsigned row)
{  // set which scanline in the display buffer to start showing on the screen
u08 cur;

cur = erase_cursor();
   cs_high();
   cs2_high();
   send_command(SET_LINE, row);
   cs_low();
   cs2_low();
if(cur) show_cursor();
}


void lcd_xinit(u08 x)
{
   // set control port bit outputs  DDRG bit 2,  DDRC upper 5 bits
   DDRC |= 0xF8;   
   DDRG |= 0x04;

   e_low();
   cs_low();           // deselect LCD
   cs2_low();
   rw_high();          // read mode
   rs_high();

   reset_low();
   delay_ms(100);
   reset_high();
   delay_ms(100);

   cs_high();
   cs2_high();
   send_command(DISPLAY_ON, 0);
   cs_low();
   cs2_low();
}


void fill_screen(COLOR data)
{
u08 page;
COORD col;
u08 cur;

cur = erase_cursor();


   #ifdef MDT_CODE
    if(mdtHooked) mdt_clear(data);  // color
    if(mdtNoLocalDisplay) return;
   #endif



   cs_high();    //!!!enable writes to both controllers
   cs2_high();

   for(page=0; page<PAGES; page++) {
      send_command(SET_PAGE | page, 0);
      send_command(SET_COL | 0x00, 0);

      for(col=0; col<(COLS/2); col++) { // write both controllers at same time
         cmd_wait();      //!!! possible bus contention on busy bit?
         rs_high();       //!!! but lots of other code does this

         rw_low();
         data_out(data);
         clock_e();
         rw_high();
      }
   }

   cs_low();
   cs2_low();
if(cur) show_cursor();
}

#endif   //KS0107



#ifdef KS0713

// send command to the LCD
void LCD_command(u08 command)
{
   rs_low();
   rd_high();

   LCD_out(command);
   rw_low();
   rw_high();
}


u08 read_screen(COORD col,COORD row)
{  /* get screen byte that contains screen coordinate (col, row) */
u08 c;
unsigned addr;

   // set column  MSB
   LCD_command(0x10 | (col >> 4));
   // set column LSB
   LCD_command(0x0F & col);
    
   // set page
   LCD_command(0xB0 | (0x0F & (row >> 3)));

   rs_high();

   rd_low();   // dummy read cycle
   rd_high();

   rd_low()
   c = DATA_PORT_READ;
   return c;
}

void write_screen(COORD col, COORD row, u08 data)
{
    // set column  MSB
    LCD_command(0x10 | (col >> 4));
    // set column LSB
    LCD_command(0x0F & col);
    
    // set page
    LCD_command(0xB0 | (0x0F & (row >> 3)));
    
    //Data write   
    rd_high();
    rs_high();

    LCD_out(data);
    rw_low();
    rw_high();

    rd_low(); //Must have this! Or else the screen will shimmer black   
}

void fill_screen(COLOR data)
{
u16 count; 

    // set column  MSB
    LCD_command(0x10 | (0x00 >> 4));
    // set column LSB
    LCD_command(0x0F & 0x00);
    
    // set page
    LCD_command(0xB0 | (0x0F & (0x00 >> 3)));

    rd_high();
    rs_high();
    LCD_out(data);

    count = ROWS*COLS;
    while(count--) {
       rw_low();
       rw_high();
    }

    rd_low(); //Must have this! Or else the screen will shimmer black   
}


void lcd_xinit(u08 mode);
{
   // set control port bit outputs  DDRG bit 2,  DDRC upper 5 bits
   DDRC |= 0xF8;   
   DDRG |= 0x04;

   cs_low();           // deselect LCD
   rw_high(); 
   rs_high();
   rd_high();

   delay_ms(100);
   reset_low();
   delay_ms(100);
   rest_high();
   delay_ms(100);

   LCD_command(0xAF); //On LCD

   //Best boot 5-1-05
   LCD_command(0xA3); //LCD Bias (A2 A3) - First Choice
   LCD_command(0x2F); //Turn on internal power control
   LCD_command(0x26); //Pseudo-Contrast 7 = dark 6 = OK - First Choice

   LCD_command(0x81); //Set contrast
   LCD_command(54); 

   LCD_command(0xC8); //Flip screen on the horizontal to match with the vertical software invertion
}
#endif  //KS0713

//
//  The following code is semi device independent for column oriented
//  LCD controllers.  Only read_screen() and write_screen() are used
//  to access the hardware.
//


u08 read_screen_byte(u16 addr)
{
u08 row, col;

   col = (addr % COLS);
   row = (addr / COLS) * PAGES;
   return read_screen(col, row);
}

void write_screen_byte(u16 addr, u08 val)
{
u08 row, col;

   col = (addr % COLS);
   row = (addr / COLS) * PAGES;
   write_screen(col, row, val);
}



void dot(COORD col,COORD row)
{
u08 cur;
u08 c;
u08 pixel;

   if(col >= COLS) return;  /* !!!  cliping */
   else if(row >= ROWS) return;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_dot(col,row);
   #endif 


cur = erase_cursor();
   c = read_screen(col, row);

   if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) {  // raster op pixel to screen
      pixel = c & pixel_masks[row & 0x07];
      if(draw_flags & BLIT_AND) {
         if(pixel && color) c |= pixel_masks[row & 0x07];
         else c &= (~pixel_masks[row & 0x07]);
      }
      else if(draw_flags & BLIT_OR) {
         if(pixel || color) c |= pixel_masks[row & 0x07];
         else c &= (~pixel_masks[row & 0x07]);
      }
      else if(draw_flags & BLIT_XOR) {
         if(pixel) {
            if(color == 0) c |= pixel_masks[row & 0x07];
            else c &= (~pixel_masks[row & 0x07]);
         }
         else {
            if(color) c |= pixel_masks[row & 0x07];
            else c &= (~pixel_masks[row & 0x07]);
         }
      }
   }
   else {  // copy pixel to screen
      if(color) c |= pixel_masks[row & 0x07];
      else c &= (~pixel_masks[row & 0x07]);
   }

   write_screen(col, row, c);

if(cur) show_cursor();
}


u08 left_mask[8] = {
   0x00, 0x01, 0x03, 0x07, 0x0F,  0x1F, 0x3F, 0x7F
};
u08 right_mask[8] = {
   0xFE, 0xFC, 0xF8, 0xF0,   0xE0, 0xC0, 0x80, 0x00
};


void lcd_char(COORD col,COORD row, unsigned char c)
{
u08 pattern;
u08 mask;
COLOR temp_color;
COORD temp_coord;
COORD b_row;
COORD b_col;
u08 cg_col;
u08 cur;

   #ifdef MDT_CODE
     u08 hs = mdtHooked;
     if(mdtHooked) mdt_charxy(c,col,row);
	 mdtHooked = 0;
   #endif

cur = erase_cursor();

   // check for special drawing cases
   if(row & 0x07) pattern = 1;  // unaligned character
   else if(char_size > 1) pattern = 2;     // char is scaled up in size
   else if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR | DITHERED)) pattern = 3;
   else if(rotate & ROT_CHAR_90) pattern = 4; // char is rotated 90/270 degrees
   else pattern = 0;   // a simple byte aligned char draws fastest

   if(pattern == 0) {  // simple, aligned character
      for(cg_col=0; cg_col<CHAR_WIDTH; cg_col++) {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_WIDTH + ((rotate&ROT_CHAR_HORIZ)?(CHAR_WIDTH-1-cg_col): cg_col)]); /* !!! multiply */
         if(rotate & ROT_CHAR_VERT) pattern = reverse(pattern);
         if(bg_color >= color) {  /* !!! */
            pattern = (~pattern);
         }
         write_screen(col,row, pattern);
         ++col;
      }
if(cur) show_cursor();

      #ifdef MDT_CODE 
	  mdtHooked = hs;  // restore 
	  #endif 

      return;
   }

   // Chars that are rotated, scaled, raster oped, or not byte aligned:
   // We draw them by building a buffer with each char row pattern expanded 
   // by *char_size*.  We then use blit() to do a memory to screen copy.
   // Only one call to blit is needed for each row of non-dithered big chars.
   // Dithered chars require individual blits for each expanded sub-row 
   // of big chars.
   //
   for(cg_col=0; cg_col<CHAR_WIDTH; cg_col++) {
      if(rotate & ROT_CHAR_90) {   // generate pattern for a rotated character
         pattern = 0x00;
         for(b_row=0; b_row<CHAR_WIDTH; b_row++) {
            b_col = pgm_read_byte_near(&cgen[c*CHAR_WIDTH + ((rotate&ROT_CHAR_HORIZ)?(CHAR_WIDTH-1-b_row): b_row)]); /* !!! multiply */
            if(b_col & pixel_masks[(rotate & ROT_CHAR_VERT)?(CHAR_WIDTH-1-cg_col): cg_col]) pattern |= pixel_masks[b_row];
         }
      }
      else {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_WIDTH + ((rotate&ROT_CHAR_HORIZ)?(CHAR_WIDTH-1-cg_col): cg_col)]); /* !!! multiply */
         if(rotate & ROT_CHAR_VERT) pattern = reverse(pattern);
      }

      if(bg_color >= color) {  /* !!! */
         pattern = (~pattern);
      }

      // expand cgen char pattern into blit_buf (properly aligned to the
      // screen destination)
      for(b_col=0; b_col<char_size; b_col++) {  // expand cgen row horizintally
         b_row = row;
         for(mask=0x01; mask; mask<<=1) {  //!!!! assumes CHAR_WIDTH==8
            for(temp_coord=0; temp_coord<char_size; temp_coord++) {  // expand cgen horizontally
               if(pattern & mask) {  // drawing a "dark" pixel
                  if(draw_flags & DITHERED) {
                     if(col & 0x01) temp_color = (~color);
                     else temp_color = color;
                     if(temp_color & pixel_masks[(row+b_row)&0x07]) temp_color = 0xFF;
                     else temp_color = 0x00;
                  }
                  else temp_color = 0xFF;
               }
               else temp_color = 0x00;

               if(temp_color) blit_buf[b_row>>3] |= pixel_masks[b_row&0x07];
               else blit_buf[b_row>>3] &= (~pixel_masks[b_row&0x07]);
               if(++b_row >= ROWS) break;  //!!! note: buffer is COLS/8 wide, not ROWS/8
            }
         }

         if(draw_flags & DITHERED) { // most draw each expanded cgen row individually 
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, 0,CHAR_HEIGHT*char_size-1, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            col += 1;
         }
         else {  // we can blit out all expanded cgen sub-rows at once
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, char_size-1,CHAR_HEIGHT*char_size-1, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            col += char_size;
            break;
         }
      }
   }
if(cur) show_cursor();

   #ifdef MDT_CODE 
   mdtHooked = hs;  // restore 
   #endif 
}


void blit(
   COORD left,COORD top,  
   COORD right,COORD bot,  
   COORD dest_left,COORD dest_top
)
{
COORD out_top, out_bot;
COORD temp;
unsigned ofs;
INCREMENT delta;
COORD bytes;
char i;
char align;
char col_incr;
COORD col_count;
COORD src_col;
COORD dest_col;
u08 cur;

   #ifdef MDT_CODE
      if(mdtHooked) mdt_blit(left,top,  right,bot,  dest_left,dest_top);
   #endif

   if(top > bot) {  /* normalize coordinates */
      temp = top;
      top = bot;
      bot = temp;
   }

   if(left > right) {
      temp = left;
      left = right;
      right = temp;
   }

   if(right >= COLS) right = COLS-1;   //!!! cliping
   if(bot >= ROWS) bot = ROWS-1;       //!!! cliping

   if(dest_left >= COLS) return;   /* ignore blits off the edge */
   ofs = dest_left + (right-left);
   if(ofs >= COLS) {         /* part of blit is off the edge */
      right -= (ofs-COLS+1); /* no need to blit it, adjust blit size */
      if(right < left) return;
   }

   if(1) {    //!!! don't allow off screen blits to wrap
      if(dest_top >= ROWS) return;    /* ignore blits off the edge */
      ofs = dest_top + (bot-top);
      if(ofs >= ROWS) {         /* part of blit is off the edge */
         bot -= (ofs-ROWS+1);   /* no need to blit it, adjust blit size */
         if(bot < top) return;
      }
   }

cur = erase_cursor();
   delta = dest_top >> 3;
   ofs = delta;
   align = (dest_top & 0x07) - (top & 0x07);

   if(align > 4) {  /* turn 5,6,7 bit shifts into a 1,2,3 bit plus a byte offset */
      align -= 8;
      ++delta;
   }
   else if(delta && (align < (-4))) {
      align += 8;
      --delta;
   }

   col_count = right - left + 1;
   if(dest_left > left) {  /* forward blit goes right to left */
      col_incr = (-1);
      src_col = right;
      dest_col = dest_left + col_count - 1;
   }
   else {  /* backwards blit goes left to right */
      col_incr = 1;
      src_col = left;
      dest_col = dest_left;
   }

   while(col_count--) {  /* for each col of the blit */
      /* get source screen column into working buffer */
      bytes = 0; 
      if(draw_flags & BLIT_WRITE) {  // blit source is char buffer
         if((draw_flags & BLIT_ALIGNED) == 0) {
            temp = ((bot + 1) >> 3) + 1;
            while(temp--) {
               blit_buf[delta+temp] = blit_buf[temp];
               ++bytes;
            }
         }
      }
      else if(draw_flags & (FILLED | DITHERED)) {  /* blit source is color pattern */
         if((draw_flags & BLIT_ALIGNED) == 0) {
            if((draw_flags & DITHERED) && (dest_col & 1)) {
               for(temp=top; temp<=bot+8; temp+=8) {
                  blit_buf[delta+bytes] = (~color);
                  ++bytes;
               }
            }
            else {
               for(temp=top; temp<=bot+8; temp+=8) {
                  blit_buf[delta+bytes] = color;
                  ++bytes;
               }
            }
         }
      }
      else {   /* blit source is screen memory */
         for(temp=top; temp<=bot+1; temp+=8) {
            blit_buf[delta+bytes] = read_screen(src_col, temp);
            ++bytes;
         }
      }

      if((draw_flags & BLIT_ALIGNED) == 0) {
         temp = align;
         if(align > 0) {  /* align source pixels to match destination bytes */
            while(temp--) {
                for(i=bytes-1; i>=0; i--) {
                   blit_buf[ofs+i] <<= 1;
                   if(blit_buf[ofs+i-1] & 0x80) blit_buf[ofs+i] |= 0x01;
                }
            }
         }
         else if(align < 0) {
            while(temp++) {
               for(i=0; i<bytes; i++) {
                  blit_buf[ofs+i] >>= 1;
                  if(blit_buf[ofs+i+1] & 0x01) blit_buf[ofs+i] |= 0x80;
               }
            }
         }
      }
      if(draw_flags & DITHERED) set_draw_flags(draw_flags & (~BLIT_ALIGNED));
      else if(draw_flags & (BLIT_WRITE | FILLED)) set_draw_flags(draw_flags | BLIT_ALIGNED);   // only need to align source buffer once

      out_top = dest_top;
      out_bot = dest_top + (bot-top);

#define top_mask left_mask
#define bot_mask right_mask
      /* head 'em up,  move 'em out */
      if(((out_top & (~0x07)) == (out_bot & (~0x07)))) {  /* short lines all in the same byte */
         temp = top_mask[out_top&0x07] | bot_mask[out_bot&0x07];
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp = (read_screen(dest_col, out_top) & temp) | (blit_buf[out_top>>3] & (~temp));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp = read_screen(dest_col, out_top) | (blit_buf[out_top>>3] & (~temp));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp = read_screen(dest_col, out_top) & (temp | (blit_buf[out_top>>3] & (~temp)));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp = read_screen(dest_col, out_top) ^ (blit_buf[out_top>>3] & (~temp));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_top>>3] = temp;
         else write_screen(dest_col, out_top, temp);
         goto next_col;
      }

      if(out_top & 0x07) {  /* unaligned pixels on the top end */
         temp = read_screen(dest_col, out_top);
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp &= top_mask[out_top&0x07];
            temp |= (blit_buf[out_top>>3] & (~top_mask[out_top & 0x07]));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp |= (blit_buf[out_top>>3] & (~top_mask[out_top & 0x07]));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp &= (top_mask[out_top & 0x07] | (blit_buf[out_top>>3] & (~top_mask[out_top & 0x07])));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp ^= (blit_buf[out_top>>3] & (~top_mask[out_top & 0x07]));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_top>>3] = temp;
         else write_screen(dest_col, out_top, temp);
         out_top += (8 - (out_top & 0x07));
      }

      if((out_bot & 0x07) != 0x07) {  /* unaligned pixels on the bottom end */
         temp = read_screen(dest_col, out_bot);
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp &= bot_mask[out_bot&0x07];
            temp |= (blit_buf[out_bot>>3] & (~bot_mask[out_bot & 0x07]));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp |= (blit_buf[out_bot>>3] & (~bot_mask[out_bot & 0x07]));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp &= (bot_mask[out_bot & 0x07] | (blit_buf[out_bot>>3] & (~bot_mask[out_bot & 0x07])));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp ^= (blit_buf[out_bot>>3] & (~bot_mask[out_bot & 0x07]));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_bot>>3] = temp;
         else write_screen(dest_col, out_bot, temp);
         out_bot -= (out_bot & 0x07);
         if(out_bot >= ROWS) goto next_col;   //!!! cliping
      }

      if(out_top < out_bot) { /* use byte writes to zap out the middle of the line */
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {  /* plain bit copy */
            if(draw_flags & BLIT_READ) goto next_col;
            while(out_top < out_bot) {
               write_screen(dest_col, out_top, blit_buf[out_top>>3]);
               out_top += 8;
            }
         }
         else {  /* copy with raster operation */
            while(out_top < out_bot) {
               temp = read_screen(dest_col, out_top);
               if(draw_flags & BLIT_OR) temp |= blit_buf[out_top>>3];
               else if(draw_flags & BLIT_AND) temp &= blit_buf[out_top>>3];
               else if(draw_flags & BLIT_XOR) temp ^= blit_buf[out_top>>3];

               if(draw_flags & BLIT_READ) blit_buf[out_top>>3] = temp;
               else write_screen(dest_col, out_top, temp);
               out_top += 8;
            }
         }
      }

      next_col:
      src_col += col_incr;
      dest_col += col_incr;
   }

   set_draw_flags(draw_flags & (~BLIT_ALIGNED));
if(cur) show_cursor();
}

