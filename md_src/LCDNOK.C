/*  MegaDonkey Library File:  LCDNOK.c    NOKIA LCD DRIVER     


    Copyright 2007,2008  Mark Sims & Ron Grant


    This file is part of The Megadonkey Software Library.

    The Megadonkey Software Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Megadonkey Software Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
    more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the Megadonkey Software Library. If not, see <http://www.gnu.org/licenses/>.


  

   Low level graphics driver for EPSON S1D15G10 Color LCDs
   Mark Sims
   July 1, 2007
  
     
   Panel Command Interface
   Screen Read/Write
   Character Generator (character bitmap)
   Character Drawing 
   Dot Plotting
   Blts


 This file is included in lcd.c and should not be included in IDE project, but
 instead may be added in the Other Files folder of the IDE.
 If the file is added to the IDE project you will get all kinds of errors.

 ALSO, if editing in IDE -- BE SURE to explicity save the file before 
 recompiling project -- IDE/MakeUtility will not notice if this file included 
 within LCD.C is out of date.

 This .c file does not have an associated header file.


 
 Sets up panel for 132x132 8 bits per pixel with 9 bit serial interface.

  *** NOTE: You cannot read back the display RAM in serial mode.
            Most BLIT functions will not work.


*/

#define EXTERN extern

#ifdef HCDEMO
   #include "hcdemo.c"  //!!!!
#endif

#define reverse(x) pgm_read_byte_near(&rvs_table[x])

// LCD 8 Bit Data Bus
#define DATA_PORT       PORTA      // 8 bit bi-directional data port
#define DATA_PORT_DDR   DDRA       // Data Direction Register for Data Port

#ifdef REVERSE_DB
   #define data_out(byte)  DATA_PORT = reverse(byte)
   #define DATA_PORT_READ  reverse(PINA)
   #define DATA_PORT_BUSY  bit_is_set(PINA,0)
#else
   #define data_out(byte)  DATA_PORT = byte
   #define DATA_PORT_READ  PINA
   #define DATA_PORT_BUSY  bit_is_set(PINA,7)
#endif


// NOP is used when compiling with optimizer on... 
// it is needed to make clock signals compatible with the LCD controller chip specs
//#define NOP asm volatile ("nop");  asm volatile ("nop");  asm volatile ("nop");
#define NOP

#define rw_low()  cbi(PORTC,4); DATA_PORT_DDR = 0xFF
#define rw_high() PORTA=0xFF; DATA_PORT_DDR=0x00; sbi(PORTC,4)
#define cs_low()  cbi(PORTC,5); NOP
#define cs_high() sbi(PORTC,5); NOP
#define rs_low()  cbi(PORTC,3); NOP // RS is used as serial data out
#define rs_high() sbi(PORTC,3); NOP
#define e_low()   cbi(PORTG,2); NOP
#define e_high()  sbi(PORTG,2); NOP
#define clock_e() e_high(); e_low()
#define reset_low() cbi(PORTC,7)
#define reset_high() sbi(PORTC,7)

u08 bus_in_use(void)
{
   if(PINC & _BV(5)) return 0;
   else return 1;
}



// Epson S1D15G10 Command Set

#define DISON       0xaf   
#define DISOFF      0xae   
#define DISNOR      0xa6  
#define DISINV      0xa7  
#define COMSCN      0xbb   
#define DISCTL      0xca   
#define SLPIN       0x95   
#define SLPOUT      0x94   
#define PASET       0x75   
#define CASET       0x15   
#define DATCTL      0xbc   
#define RGBSET8     0xce   
#define RAMWR       0x5c   
#define RAMRD       0x5d   
#define PTLIN       0xa8   
#define PTLOUT      0xa9   
#define RMWIN       0xe0   
#define RMWOUT      0xee   
#define ASCSET      0xaa   
#define SCSTART     0xab   
#define OSCON       0xd1   
#define OSCOFF      0xd2   
#define PWRCTR      0x20   
#define VOLCTR      0x81   
#define VOLUP       0xd6   
#define VOLDOWN     0xd7   
#define TMPGRD      0x82   
#define EPCTIN      0xcd   
#define EPCOUT      0xcc   
#define EPMWR       0xfc   
#define EPMRD       0xfd   
#define EPSRRD1     0x7c   
#define EPSRRD2     0x7d   
#define LCD_NOP     0x25    

// --------------------------------------------------------------------------------------

u08 pixel_masks[] = {
   0x01, 0x02, 0x04, 0x08,  0x10, 0x20, 0x40, 0x80
};

u08 rvs_table[] PROGMEM = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};


u08 cgen[] PROGMEM = {  // the character generator table
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 00    
   0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,   // 01    
   0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,   // 02    
   0x36, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 03    
   0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 04    
   0x1C, 0x3E, 0x1C, 0x7F, 0x7F, 0x3E, 0x1C, 0x3E,   // 05    
   0x08, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x3E,   // 06    
   0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,   // 07    
   0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,   // 08    
   0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,   // 09    
   0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,   // 0A    
   0xF0, 0xE0, 0xF0, 0xBE, 0x33, 0x33, 0x33, 0x1E,   // 0B    
   0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,   // 0C    
   0xFC, 0xCC, 0xFC, 0x0C, 0x0C, 0x0E, 0x0F, 0x07,   // 0D    
   0xFE, 0xC6, 0xFE, 0xC6, 0xC6, 0xE6, 0x67, 0x03,   // 0E    
   0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,   // 0F    
   0x01, 0x07, 0x1F, 0x7F, 0x1F, 0x07, 0x01, 0x00,   // 10    
   0x40, 0x70, 0x7C, 0x7F, 0x7C, 0x70, 0x40, 0x00,   // 11    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,   // 12    
   0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,   // 13    
   0xFE, 0xDB, 0xDB, 0xDE, 0xD8, 0xD8, 0xD8, 0x00,   // 14    
   0x7C, 0xC6, 0x1C, 0x36, 0x36, 0x1C, 0x33, 0x1E,   // 15    
   0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,   // 16    
   0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,   // 17    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,   // 18    
   0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,   // 19    
   0x00, 0x18, 0x30, 0x7F, 0x30, 0x18, 0x00, 0x00,   // 1A    
   0x00, 0x0C, 0x06, 0x7F, 0x06, 0x0C, 0x00, 0x00,   // 1B    
   0x00, 0x00, 0x03, 0x03, 0x03, 0x7F, 0x00, 0x00,   // 1C    
   0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,   // 1D    
   0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,   // 1E    
   0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,   // 1F    
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 20    
   0x0C, 0x1E, 0x1E, 0x1E, 0x0C, 0x00, 0x0C, 0x00,   // 21  ! 
   0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,   // 22  " 
   0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,   // 23  # 
   0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00,   // 24  $ 
   0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,   // 25  % 
   0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,   // 26  & 
   0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // 27  ' 
   0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,   // 28  ( 
   0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,   // 29  ) 
   0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 2A  * 
   0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,   // 2B  + 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 2C  , 
   0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,   // 2D  - 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 2E  . 
   0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,   // 2F  / 
   0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 30  0 
   0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,   // 31  1 
   0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,   // 32  2 
   0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,   // 33  3 
   0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,   // 34  4 
   0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,   // 35  5 
   0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,   // 36  6 
   0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,   // 37  7 
   0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 38  8 
   0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,   // 39  9 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 3A  : 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 3B  ; 
   0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,   // 3C  < 
   0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,   // 3D  = 
   0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 3E  > 
   0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,   // 3F  ? 
   0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,   // 40  @ 
   0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,   // 41  A 
   0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,   // 42  B 
   0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,   // 43  C 
   0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,   // 44  D 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x7E, 0x00,   // 45  E 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x06, 0x00,   // 46  F 
   0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,   // 47  G 
   0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,   // 48  H 
   0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 49  I 
   0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,   // 4A  J 
   0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,   // 4B  K 
   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7E, 0x00,   // 4C  L 
   0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,   // 4D  M 
   0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,   // 4E  N 
   0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,   // 4F  O 
   0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,   // 50  P 
   0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,   // 51  Q 
   0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,   // 52  R 
   0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,   // 53  S 
   0x3F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x00,   // 54  T 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,   // 55  U 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 56  V 
   0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 57  W 
   0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,   // 58  X 
   0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,   // 59  Y 
   0x7F, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x7F, 0x00,   // 5A  Z 
   0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00,   // 5B  [ 
   0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 5C  back slash
   0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00,   // 5D  ] 
   0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00,   // 5E  ^ 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 5F  _ 
   0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 60  ` 
   0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 61  a 
   0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00,   // 62  b 
   0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00,   // 63  c 
   0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00,   // 64  d 
   0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 65  e 
   0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00,   // 66  f 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 67  g 
   0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00,   // 68  h 
   0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 69  i 
   0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E,   // 6A  j 
   0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00,   // 6B  k 
   0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 6C  l 
   0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 6D  m 
   0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00,   // 6E  n 
   0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 6F  o 
   0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F,   // 70  p 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78,   // 71  q 
   0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00,   // 72  r 
   0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00,   // 73  s 
   0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00,   // 74  t 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 75  u 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 76  v 
   0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 77  w 
   0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00,   // 78  x 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 79  y 
   0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00,   // 7A  z 
   0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00,   // 7B  { 
   0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 7C  | 
   0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00,   // 7D  } 
   0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 7E  ~ 
   0x00, 0x08, 0x1C, 0x36, 0x63, 0x63, 0x7F, 0x00,   // 7F   

   0x3E, 0x63, 0x03, 0x63, 0x3E, 0x30, 0x60, 0x3E,   // 80  € 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 81   
   0x38, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 82  ‚ 
   0x7E, 0x81, 0x3C, 0x60, 0x7C, 0x66, 0xDC, 0x00,   // 83  ƒ 
   0x33, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 84  „ 
   0x07, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 85  … 
   0x0C, 0x0C, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 86  † 
   0x00, 0x00, 0x3E, 0x63, 0x03, 0x1E, 0x30, 0x1C,   // 87  ‡ 
   0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x06, 0x3C, 0x00,   // 88  ˆ 
   0x33, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 89  ‰ 
   0x07, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 8A  Š 
   0x33, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8B  ‹ 
   0x3E, 0x41, 0x1C, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 8C  Œ 
   0x07, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8D   
   0x63, 0x08, 0x3E, 0x63, 0x7F, 0x63, 0x63, 0x00,   // 8E  Ž 
   0x0C, 0x0C, 0x00, 0x1E, 0x33, 0x3F, 0x33, 0x00,   // 8F   
   0x38, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00,   // 90   
   0x00, 0x00, 0xFE, 0x30, 0xFE, 0x33, 0xFE, 0x00,   // 91  ‘ 
   0x7C, 0x36, 0x33, 0x7F, 0x33, 0x33, 0x73, 0x00,   // 92  ’ 
   0x1E, 0x21, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 93  “ 
   0x00, 0x33, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 94  ” 
   0x00, 0x07, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 95  • 
   0x1E, 0x21, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 96  – 
   0x00, 0x07, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 97  — 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 98  ˜ 
   0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 99  ™ 
   0x33, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 9A  š 
   0x18, 0x18, 0x7E, 0x03, 0x03, 0x7E, 0x18, 0x18,   // 9B  › 
   0x1C, 0x36, 0x26, 0x0F, 0x06, 0x67, 0x3F, 0x00,   // 9C  œ 
   0x33, 0x33, 0x1E, 0x0C, 0x3F, 0x0C, 0x3F, 0x0C,   // 9D   
   0x1F, 0x33, 0x33, 0x5F, 0x63, 0xF3, 0x63, 0xC3,   // 9E  ž 
   0x70, 0xD8, 0x18, 0x3C, 0x18, 0x18, 0x1B, 0x0E,   // 9F  Ÿ 
   0x38, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // A0    
   0x1C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // A1  ¡ 
   0x00, 0x38, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // A2  ¢ 
   0x00, 0x38, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // A3  £ 
   0x00, 0x1F, 0x00, 0x1D, 0x33, 0x33, 0x33, 0x00,   // A4  ¤ 
   0x3F, 0x00, 0x33, 0x37, 0x3F, 0x3B, 0x33, 0x00,   // A5  ¥ 
   0x3C, 0x36, 0x36, 0x7C, 0x00, 0x7E, 0x00, 0x00,   // A6  ¦ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x3E, 0x00, 0x00,   // A7  § 
   0x18, 0x00, 0x18, 0x18, 0x0C, 0x66, 0x3C, 0x00,   // A8  ¨ 
   0x00, 0x00, 0x00, 0x3F, 0x03, 0x03, 0x00, 0x00,   // A9  © 
   0x00, 0x00, 0x00, 0x3F, 0x30, 0x30, 0x00, 0x00,   // AA  ª 
   0x63, 0x33, 0x1B, 0x6C, 0xD6, 0x43, 0x21, 0xF0,   // AB  « 
   0xC3, 0x63, 0x33, 0xDB, 0xEC, 0xB6, 0xF3, 0xC0,   // AC  ¬ 
   0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,   // AD  ­ 
   0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,   // AE  ® 
   0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,   // AF  ¯ 
   0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11,   // B0  ° 
   0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,   // B1  ± 
   0xDB, 0x6F, 0xDB, 0xF6, 0xDB, 0x7E, 0xEB, 0xB7,   // B2  ² 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,   // B3  ³ 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B4  ´ 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B5  µ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6F, 0x6C, 0x6C, 0x6C,   // B6  ¶ 
   0x00, 0x00, 0x00, 0x00, 0x7F, 0x6C, 0x6C, 0x6C,   // B7  · 
   0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B8  ¸ 
   0x6C, 0x6C, 0x6F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // B9  ¹ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C,   // BA  º 
   0x00, 0x00, 0x7F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // BB  » 
   0x6C, 0x6C, 0x6F, 0x60, 0x7F, 0x00, 0x00, 0x00,   // BC  ¼ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x7F, 0x00, 0x00, 0x00,   // BD  ½ 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,   // BE  ¾ 
   0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18,   // BF  ¿ 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,   // C0  À 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,   // C1  Á 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,   // C2  Â 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C3  Ã 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,   // C4  Ä 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,   // C5  Å 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C6  Æ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xEC, 0x6C, 0x6C, 0x6C,   // C7  Ç 
   0x6C, 0x6C, 0xEC, 0x0C, 0xFC, 0x00, 0x00, 0x00,   // C8  È 
   0x00, 0x00, 0xFC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // C9  É 
   0x6C, 0x6C, 0xEF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CA  Ê 
   0x00, 0x00, 0xFF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CB  Ë 
   0x6C, 0x6C, 0xEC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // CC  Ì 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CD  Í 
   0x6C, 0x6C, 0xEF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CE  Î 
   0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CF  Ï 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x00, 0x00, 0x00,   // D0  Ð 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,   // D1  Ñ 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x6C, 0x6C, 0x6C,   // D2  Ò 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFC, 0x00, 0x00, 0x00,   // D3  Ó 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,   // D4  Ô 
   0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // D5  Õ 
   0x00, 0x00, 0x00, 0x00, 0xFC, 0x6C, 0x6C, 0x6C,   // D6  Ö 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x6C, 0x6C, 0x6C,   // D7  × 
   0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,   // D8  Ø 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00,   // D9  Ù 
   0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,   // DA  Ú 
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // DB  Û 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,   // DC  Ü 
   0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,   // DD  Ý 
   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,   // DE  Þ 
   0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,   // DF  ß 
   0x00, 0x00, 0x6E, 0x3B, 0x13, 0x3B, 0x6E, 0x00,   // E0  à 
   0x00, 0x1E, 0x33, 0x1F, 0x33, 0x1F, 0x03, 0x03,   // E1  á 
   0x00, 0x3F, 0x33, 0x03, 0x03, 0x03, 0x03, 0x00,   // E2  â 
   0x00, 0x00, 0x7F, 0x36, 0x36, 0x36, 0x36, 0x00,   // E3  ã 
   0x3F, 0x33, 0x06, 0x0C, 0x06, 0x33, 0x3F, 0x00,   // E4  ä 
   0x00, 0x00, 0x7E, 0x1B, 0x1B, 0x1B, 0x0E, 0x00,   // E5  å 
   0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x03,   // E6  æ 
   0x00, 0x6E, 0x3B, 0x18, 0x18, 0x18, 0x18, 0x00,   // E7  ç 
   0x3F, 0x0C, 0x1E, 0x33, 0x33, 0x1E, 0x0C, 0x3F,   // E8  è 
   0x1C, 0x36, 0x63, 0x7F, 0x63, 0x36, 0x1C, 0x00,   // E9  é 
   0x1C, 0x36, 0x63, 0x63, 0x36, 0x36, 0x77, 0x00,   // EA  ê 
   0x38, 0x0C, 0x18, 0x3E, 0x33, 0x33, 0x1E, 0x00,   // EB  ë 
   0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,   // EC  ì 
   0x60, 0x30, 0x7E, 0xDB, 0xDB, 0x7E, 0x06, 0x03,   // ED  í 
   0x1C, 0x06, 0x03, 0x1F, 0x03, 0x06, 0x1C, 0x00,   // EE  î 
   0x1E, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00,   // EF  ï 
   0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,   // F0  ð 
   0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,   // F1  ñ 
   0x06, 0x0C, 0x18, 0x0C, 0x06, 0x00, 0x3F, 0x00,   // F2  ò 
   0x18, 0x0C, 0x06, 0x0C, 0x18, 0x00, 0x3F, 0x00,   // F3  ó 
   0x70, 0xD8, 0xD8, 0x18, 0x18, 0x18, 0x18, 0x18,   // F4  ô 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x1B, 0x1B, 0x0E,   // F5  õ 
   0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,   // F6  ö 
   0x00, 0x6E, 0x3B, 0x00, 0x6E, 0x3B, 0x00, 0x00,   // F7  ÷ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,   // F8  ø 
   0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,   // F9  ù 
   0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,   // FA  ú 
   0xF0, 0x30, 0x30, 0x30, 0x37, 0x36, 0x3C, 0x38,   // FB  û 
   0x1A, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,   // FC  ü 
   0x0E, 0x19, 0x0C, 0x06, 0x1F, 0x00, 0x00, 0x00,   // FD  ý 
   0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,   // FE  þ 
   0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00    // FF  ÿ 
};


/* ----------------- LCD controller command routines ----------------- */

void spi_command(u08 cmd)
{
   rs_low();
   clock_e();

   if(cmd & 0x80)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x40)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x20)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x10)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x08)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x04)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x02)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x01)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
}

void spi_data(u08 cmd)
{
   rs_high(); 
   clock_e();

   if(cmd & 0x80)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x40)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x20)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x10)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x08)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x04)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x02)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
   if(cmd & 0x01)  { rs_high(); }
   else  { rs_low(); }
   clock_e();
}


void set_addr(COORD col,COORD row)
{
   cs_low();

   spi_command(PASET);   // page start/end ram
   row += ROW_OFS;       // for some reason starts at 2
   spi_data(row);            
   spi_data(ROWS+1);          

   spi_command(CASET);   // column start/end ram
   spi_data(col); 
   spi_data(COLS-1); 

   cs_high();
}


void write_screen(COORD col,COORD row, COLOR data)
{  
   /* write screen byte that contains screen coordinate (col, row) */
   /*
      this routine is just:
      set_addr(col,row);
      send_command(DISP_WRT, data);
   */
   cs_low();

   spi_command(PASET);  // page start/end ram
   row += ROW_OFS;      // for some reason starts at 2
   spi_data(row);            
   spi_data(ROWS-1);          

   spi_command(CASET);  // column start/end ram
   spi_data(col);
   spi_data(COLS-1); 

   spi_command(RAMWR);  // write data
   if(sizeof(data) > 1) {
      spi_data(data>>8); 
      spi_data(data&0xFF); 
      spi_data(0x00);
      cs_high();
   }
   else {
      spi_data(data); 
      cs_high();
   }

}

COLOR read_screen(COORD col,COORD row)
{  /* get screen byte that contains screen coordinate (col, row) */
   return 0;    //!!! cant read screen via SPI port
}

u08 read_screen_byte(unsigned addr)
{
u16 temp_top;
u08 val;

   temp_top = top_line;
   top_line = addr;

   val = read_screen(0, 0);

   top_line = temp_top;
   return val;
}

void write_screen_byte(unsigned addr, u08 val)
{
u16 temp_top;

   temp_top = top_line;
   top_line = addr;

   write_screen(0, 0, val);

   top_line = temp_top;
}



void set_lcdtop(unsigned row)
{  // set which scanline in the display buffer to start showing on the screen
{
u08 cur;

cur = erase_cursor();
   cs_low();

   spi_command(LCD_NOP);

   spi_command(ASCSET);   
   spi_data(0);
   spi_data(0x3F);   //41
   spi_data(0x3F);   //41
   spi_data(0x03);   // full screen scroll mode

   spi_command(SCSTART);
   spi_data(row>>2); // can only scroll to 4 line boundaries

   cs_high();
if(cur) show_cursor();
}

void lcd_xinit(u08 mode)
{
   // set control port bit outputs  DDRG bit 2,  DDRC upper 5 bits
   DDRC |= 0xF8;  
   DDRG |= 0x04; 

   cs_high();
   e_low();

   reset_high();    // reset the panel
   delay_ms(100);
   reset_low();        
   delay_ms(100);
   reset_high();
   delay_ms(100);

   cs_low();

   spi_command(DISCTL);  // display control
   spi_data(0x02);   //03,rows,0xc
   spi_data((ROWS+ROW_OFS)/4-1);
   spi_data(0x1C);  

   spi_command(COMSCN);  // common scan direction
   spi_data(0x01);

   spi_command(OSCON);   // oscilator on

   spi_command(SLPOUT);  // sleep out

   spi_command(VOLCTR);  // electronic volume, this is kinda contrast/brightness
   spi_data(0x1C);
   spi_data(0x03);

   spi_command(TMPGRD);  // temperature compensation
   spi_data(0x01);

   spi_command(PWRCTR);  // power ctrl
   spi_data(0x0f);       //everything on, no external reference resistors
   cs_high();

   delay_ms(100);

   cs_low();
   spi_command(DISINV);  // display mode
   spi_command(PTLOUT);  // no partial display
   spi_command(RMWOUT);  // no read-modify-write

   spi_command(DATCTL);  // data control - screen scan direction
   spi_data(0x00); 
   spi_data(0x00);
   if(sizeof(color) > 1) spi_data(0x02);
   else spi_data(0x01);

   spi_command(RGBSET8);   // setup color lookup table
   spi_data(0);      //RED
   spi_data(2);
   spi_data(4);
   spi_data(6);
   spi_data(8);
   spi_data(10);
   spi_data(12);
   spi_data(15);

   spi_data(0);     // GREEN
   spi_data(2);
   spi_data(4);
   spi_data(6);
   spi_data(8);
   spi_data(10);
   spi_data(12);
   spi_data(15);

   spi_data(0);    //BLUE
   spi_data(5);
   spi_data(10);
   spi_data(15);

   spi_command(LCD_NOP); // nop
   cs_high();

   delay_ms(100);

   cs_low();
   spi_command(DISON);   // display on
   cs_high();

   delay_ms(100);

   set_addr(0,0);     // cursor/drawing address
}


void dot(COORD col,COORD row)
{
u08 cur;
COLOR c;

   if(col >= COLS) return;  /* !!!  cliping */
   else if(row >= ROWS) return;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_dot(col,row);
   #endif 

cur = erase_cursor();
   if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) {  // raster op pixel to screen
      c = read_screen(col, row);
      if(draw_flags & BLIT_AND) {
         c &= color;
      }
      else if(draw_flags & BLIT_OR) {
         c |= color;
      }
      else if(draw_flags & BLIT_XOR) {
         c ^= color;
      }
   }
   else {  // copy pixel to screen
      c = color;
   }

   cs_low();

   spi_command(PASET);      // page start/end ram
   spi_data(row+ROW_OFS);   // for some reason starts at 2
   spi_data(row+ROW_OFS);   // for some reason starts at 2
  
   spi_command(CASET);      // column start/end ram
   spi_data(col);          
   spi_data(col);          

   spi_command(RAMWR);      // write some stuff (background)
   if(sizeof(c) > 1) {
      spi_data(c>>8); 
      spi_data(c&0xFF); 
      spi_data(0x00);
      cs_high();
   }
   else {
      spi_data(c); 
      cs_high();
   }

if(cur) show_cursor();
}


void fill_screen(COLOR data)
{
unsigned i;
u08 cur;

   cur = erase_cursor();

   cs_low();
   spi_command(LCD_NOP); // nop

   spi_command(PASET);   // page start/end ram
   spi_data(0+ROW_OFS);       
   spi_data(ROWS+ROW_OFS-1);          
  
   spi_command(CASET);   // column start/end ram
   spi_data(0);          
   spi_data(COLS+ROW_OFS-1);

   if(sizeof(data) > 1) {
      COORD row,col;
      i = color;
      set_color(data);
      for(row=0; row<ROWS; row++) {
         for(col=0; col<COLS; col++) dot(col,row);
      }                                 
      set_color(i);
   }
   else {
      spi_command(RAMWR);   // write some stuff (background)
      for(i=0; i<(ROWS+ROW_OFS)*(COLS+ROW_OFS); i++){
         spi_data(data);
      }
   }

   cs_high();
   if(cur) show_cursor();
}

u08 left_mask[8] = {
   0x00, 0x01, 0x03, 0x07, 0x0F,  0x1F, 0x3F, 0x7F
};
u08 right_mask[8] = {
   0xFE, 0xFC, 0xF8, 0xF0,   0xE0, 0xC0, 0x80, 0x00
};


void lcd_char(COORD col,COORD row, unsigned char c)
{
u08 pattern;
u08 mask;
COLOR temp_color;
COORD temp_coord;
COORD b_row;
COORD b_col;
u08 cg_row;
u08 cur;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_charxy(c, col,row);
   #endif

cur = erase_cursor();

   // Chars that are color, rotated, scaled, raster op'd, or not byte aligned:
   // We draw them by building a buffer with each char row pattern expanded 
   // by *char_size*.  We then use blit() to do a memory to screen copy.
   // Only one call to blit is needed for each row of non-dithered chars.
   // Dithered chars require individual blits for each expanded sub-row 
   // of chars.
   //
   for(cg_row=0; cg_row<CHAR_HEIGHT; cg_row++) {
      if(rotate & ROT_CHAR_90) {   // generate pattern for a rotated character
         pattern = 0x00;
         for(b_col=0; b_col<CHAR_HEIGHT; b_col++) {
            b_row = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-b_col): b_col)]); /* !!! multiply */
            if(b_row & pixel_masks[(rotate & ROT_CHAR_HORIZ)?(CHAR_HEIGHT-1-cg_row): cg_row]) pattern |= pixel_masks[b_col];
         }
      }
      else {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-cg_row): cg_row)]); /* !!! multiply */
         if(rotate & ROT_CHAR_HORIZ) pattern = reverse(pattern);
      }

      // expand cgen char pattern into blit_buf (properly aligned to the
      // screen destination)
      for(b_row=0; b_row<char_size; b_row++) {  // expand cgen row vertically
         b_col = col;
         for(mask=0x01; mask; mask<<=1) {  //!!!! assumes CHAR_WIDTH==8
            for(temp_coord=0; temp_coord<char_size; temp_coord++) {  // expand cgen horizontally
               if(pattern & mask) {  // drawing a "dark" pixel
                  if(draw_flags & DITHERED) {
                     if((col+b_col)&0x01) temp_color = 1;
                     else temp_color = 0;
                     if(row & 0x01) temp_color ^= 1;
                     if(temp_color) temp_color = bg_color;
                     else temp_color = color;
                  }
                  else temp_color = color;
               }
               else temp_color = bg_color;

               blit_buf[b_col++] = temp_color;
               if(b_col >= COLS) break;
            }
         }

         if(draw_flags & DITHERED) { // most draw each expanded cgen row individually 
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,0, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += 1;
         }
         else {  // we can blit out all expanded cgen sub-rows at once
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,char_size-1, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += char_size;
            break;
         }
      }
   }

if(cur) show_cursor();
}



void blit(
   COORD left,COORD top,  
   COORD right,COORD bot,  
   COORD dest_left,COORD dest_top
)
{
COORD out_left, out_right;
COORD temp;
unsigned ofs;
INCREMENT delta;
COORD bytes;
char align;
COLOR tempc;
char row_incr;
COORD row_count;
COORD src_row;
COORD dest_row;
u08 cur;

   #ifdef MDT_CODE
      if(mdtHooked) mdt_blit(left,top,  right,bot,  dest_left,dest_top);
   #endif

   if(top > bot) {  /* normalize coordinates */
      temp = top;
      top = bot;
      bot = temp;
   }

   if(left > right) {
      temp = left;
      left = right;
      right = temp;
   }

   if(right >= COLS) right = COLS-1;   //!!! cliping

   if(dest_left >= COLS) return;   /* ignore blits off the edge */
   ofs = dest_left + (right-left);
   if(ofs >= COLS) {         /* part of blit is off the edge */
      right -= (ofs-COLS+1); /* no need to blit it, adjust blit size */
      if(right < left) return;
   }

cur = erase_cursor();
   delta = dest_left;
   ofs = delta;
   align = 0;

   row_count = bot - top + 1;
   if(dest_top > top) {  /* forward blit goes bottom to top */
      row_incr = (-1);
      src_row = bot;
      dest_row = dest_top + row_count - 1;
   }
   else {  /* backwards blit goes top to bottom */
      row_incr = 1;
      src_row = top;
      dest_row = dest_top;
   }


   while(row_count--) {  /* for each row of the blit */
      /* get source screen line into working buffer */
      bytes = 0;   
      if(draw_flags & BLIT_WRITE) {  // blit source is char buffer
         if((draw_flags & BLIT_ALIGNED) == 0) {
            temp = right+1;
            while(temp--) {
               blit_buf[delta+temp] = blit_buf[temp];
               ++bytes;
            }
         }
      }
      else if(draw_flags & (FILLED | DITHERED)) {  /* blit source is color pattern */
         if((draw_flags & BLIT_ALIGNED) == 0) {
            if(draw_flags & DITHERED) {
               if(left & 0x01) align = 1;
               else align = 0;
               if(dest_row & 1) align ^= 1;
               if(align) {
                  for(temp=left; temp<=right+0; temp+=2) {
                     blit_buf[delta+bytes] = bg_color;
                     blit_buf[delta+bytes+1] = color;
                     bytes+=2;
                  }
               }
               else {
                  for(temp=left; temp<=right+0; temp+=2) {
                     blit_buf[delta+bytes] = color;
                     blit_buf[delta+bytes+1] = bg_color;
                     bytes+=2;
                  }
               }
            }
            else {
               for(temp=left; temp<=right+0; temp++) {
                  blit_buf[delta+bytes] = color;
                  ++bytes;
               }
            }
         }
      }
      else {   /* blit source is screen memory */
         for(temp=left; temp<=right+0; temp++) {  // suck in the screen bytes
            blit_buf[delta+bytes] = read_screen(temp, src_row);   //!!!!
            ++bytes;
         }
      }

      if(draw_flags & DITHERED) set_draw_flags(draw_flags & (~BLIT_ALIGNED));
      else if(draw_flags & (BLIT_WRITE | FILLED)) set_draw_flags(draw_flags | BLIT_ALIGNED);   // only need to align source buffer once


      out_left = dest_left;
      out_right = dest_left + (right-left);

      /* head 'em up,  move 'em out */
      if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {  /* plain bit copy */
         if(draw_flags & BLIT_READ) goto next_row;
         while(out_left <= out_right) {
            write_screen(out_left, dest_row, blit_buf[out_left]);
            out_left++;
         }
      }
      else {  /* copy with raster operation */
         while(out_left <= out_right) {
            tempc = read_screen(out_left, dest_row);
            if(draw_flags & BLIT_OR) tempc |= blit_buf[out_left];
            else if(draw_flags & BLIT_AND) tempc &= blit_buf[out_left];
            else if(draw_flags & BLIT_XOR) tempc ^= blit_buf[out_left];

            if(draw_flags & BLIT_READ) blit_buf[out_left] = tempc;
            else write_screen(out_left, dest_row, tempc);
            out_left++;
         }
      }

      next_row:
      src_row += row_incr;
      dest_row += row_incr;
   }

   set_draw_flags(draw_flags & (~BLIT_ALIGNED));
if(cur) show_cursor();
}
                        

void contrast_demo(void)
{
u08 w, col;
u08 a,b;
COLOR temp_color;

   temp_color = color;
   fill_screen(BLACK);
   w = COLS/8;

   for(col=0; col<8; col++) {  // draw color bars
      set_color(color_table[col]);
      filled_box((col*w)+1,1,  (col*w)+w-1,ROWS/2-1-1);

      set_color(color_table[col+8]);
      filled_box((col*w)+1,ROWS/2+2,  (col*w)+w-1,ROWS-1-1);
   }

   set_color(WHITE);
   delay_ms(1000);

   while(1) {
      for(b=0; b<=7; b++) {
         for(a=0; a<64; a++) {
            lcd_setxy(0,0);
            printf("A=%02X B=%02X", a,b);

            cs_low();
            spi_command(VOLCTR);  // electronic volume, this is kinda contrast/brightness
            spi_data(a);
            spi_data(b);
            cs_high();

            delay_ms(250);
         }
      }
      delay_ms(2000);
   }

   set_color(temp_color); 
}

