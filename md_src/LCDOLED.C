/*  MegaDonkey Library File:  LCDOLED.c    SSD1339 OLED Color LCD DRIVER     


    Copyright 2007,2008  Mark Sims & Ron Grant


    This file is part of The Megadonkey Software Library.

    The Megadonkey Software Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Megadonkey Software Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
    more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the Megadonkey Software Library. If not, see <http://www.gnu.org/licenses/>.


  

   SSD1339 OLED Color LCD DRIVER     
   Mark Sims
   July 20, 2007
  
     
   Panel Command Interface
   Screen Read/Write
   Character Generator (character bitmap)
   Character Drawing 
   Dot Plotting
   Blts


 This file is included in lcd.c and should not be included in IDE project, but
 instead may be added in the Other Files folder of the IDE.
 If the file is added to the IDE project you will get all kinds of errors.

 ALSO, if editing in IDE -- BE SURE to explicity save the file before 
 recompiling project -- IDE/MakeUtility will not notice if this file included 
 within LCD.C is out of date.

 This .c file does not have an associated header file.



 Low level graphics driver for SSD1339 OLED Color LCDs
 Sets up panel for 128x128 8 bits per pixel with 8 bit parallel interface.


*/


#define EXTERN extern

#define MAX_COORD 132 //!!! controller barfs if this coord value is exceeded

#ifdef HCDEMO
   #include "hcdemo.c"
#endif

#define reverse(x) pgm_read_byte_near(&rvs_table[x])

// LCD 8 Bit Data Bus
#define DATA_PORT       PORTA      // 8 bit bi-directional data port
#define DATA_PORT_DDR   DDRA       // Data Direction Register for Data Port

// #define REVERSE_DB    // if you just have to have a backwards data bus connection
#define reverse(x) pgm_read_byte_near(&rvs_table[x])

#ifdef REVERSE_DB
   #define data_out(byte)  {DATA_PORT_DDR = 0xFF; DATA_PORT = reverse(byte);}
   #define DATA_PORT_READ  reverse(PINA)
#else
   #define data_out(byte)  DATA_PORT_DDR = 0xFF; DATA_PORT = (byte);
   #define DATA_PORT_READ  PINA
#endif


// The 1339 data sheet shows /RD and /WR working like address signals and
// the /CS signal like the data strobe/clock signal.  This is not how most
// "8080" compatible busses work.  For compatibility with other chips and 
// stuff one might hang on the MegaDonkey auxiliary data bus,  this code 
// uses /CS like an address signal and /WR and /RD as data strobes.   This 
// seems to work just fine and seems to cause less read glitches with the 
// SSD1339 OLED controller chip.

// NOP is used when compiling with optimizer on... 
// it is needed to make clock signals compatible with the LCD controller chip specs
#define NOP asm volatile ("nop")

#define wr_low()     cbi(PORTC,4); NOP; 
#define wr_high()    sbi(PORTC,4); NOP; NOP; // NOP;
#define rd_low()     cbi(PORTG,2); NOP; NOP; NOP; //NOP;
#define rd_high()    sbi(PORTG,2); NOP; NOP; // NOP;
#define cs_low()     cbi(PORTC,5);
#define cs_high()    sbi(PORTC,5);
#define rs_low()     cbi(PORTC,3);
#define rs_high()    sbi(PORTC,3);
#define reset_low()  cbi(PORTC,7)
#define reset_high() sbi(PORTC,7)

u08 bus_in_use(void)
{
   if(PINC & _BV(5)) return 0;
   else return 1;
}

// SSD1339 command set

// --------------------------------------------------------------------------------------

u08 pixel_masks[] = {
   0x01, 0x02, 0x04, 0x08,  0x10, 0x20, 0x40, 0x80
};

u08 rvs_table[] PROGMEM = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};


u08 cgen[] PROGMEM = {  // the character generator table
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 00    
   0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,   // 01    
   0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,   // 02    
   0x36, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 03    
   0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 04    
   0x1C, 0x3E, 0x1C, 0x7F, 0x7F, 0x3E, 0x1C, 0x3E,   // 05    
   0x08, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x3E,   // 06    
   0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,   // 07    
   0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,   // 08    
   0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,   // 09    
   0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,   // 0A    
   0xF0, 0xE0, 0xF0, 0xBE, 0x33, 0x33, 0x33, 0x1E,   // 0B    
   0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,   // 0C    
   0xFC, 0xCC, 0xFC, 0x0C, 0x0C, 0x0E, 0x0F, 0x07,   // 0D    
   0xFE, 0xC6, 0xFE, 0xC6, 0xC6, 0xE6, 0x67, 0x03,   // 0E    
   0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,   // 0F    
   0x01, 0x07, 0x1F, 0x7F, 0x1F, 0x07, 0x01, 0x00,   // 10    
   0x40, 0x70, 0x7C, 0x7F, 0x7C, 0x70, 0x40, 0x00,   // 11    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,   // 12    
   0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,   // 13    
   0xFE, 0xDB, 0xDB, 0xDE, 0xD8, 0xD8, 0xD8, 0x00,   // 14    
   0x7C, 0xC6, 0x1C, 0x36, 0x36, 0x1C, 0x33, 0x1E,   // 15    
   0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,   // 16    
   0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,   // 17    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,   // 18    
   0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,   // 19    
   0x00, 0x18, 0x30, 0x7F, 0x30, 0x18, 0x00, 0x00,   // 1A    
   0x00, 0x0C, 0x06, 0x7F, 0x06, 0x0C, 0x00, 0x00,   // 1B    
   0x00, 0x00, 0x03, 0x03, 0x03, 0x7F, 0x00, 0x00,   // 1C    
   0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,   // 1D    
   0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,   // 1E    
   0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,   // 1F    
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 20    
   0x0C, 0x1E, 0x1E, 0x1E, 0x0C, 0x00, 0x0C, 0x00,   // 21  ! 
   0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,   // 22  " 
   0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,   // 23  # 
   0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00,   // 24  $ 
   0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,   // 25  % 
   0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,   // 26  & 
   0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // 27  ' 
   0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,   // 28  ( 
   0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,   // 29  ) 
   0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 2A  * 
   0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,   // 2B  + 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 2C  , 
   0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,   // 2D  - 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 2E  . 
   0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,   // 2F  / 
   0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 30  0 
   0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,   // 31  1 
   0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,   // 32  2 
   0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,   // 33  3 
   0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,   // 34  4 
   0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,   // 35  5 
   0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,   // 36  6 
   0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,   // 37  7 
   0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 38  8 
   0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,   // 39  9 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 3A  : 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 3B  ; 
   0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,   // 3C  < 
   0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,   // 3D  = 
   0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 3E  > 
   0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,   // 3F  ? 
   0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,   // 40  @ 
   0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,   // 41  A 
   0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,   // 42  B 
   0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,   // 43  C 
   0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,   // 44  D 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x7E, 0x00,   // 45  E 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x06, 0x00,   // 46  F 
   0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,   // 47  G 
   0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,   // 48  H 
   0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 49  I 
   0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,   // 4A  J 
   0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,   // 4B  K 
   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7E, 0x00,   // 4C  L 
   0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,   // 4D  M 
   0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,   // 4E  N 
   0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,   // 4F  O 
   0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,   // 50  P 
   0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,   // 51  Q 
   0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,   // 52  R 
   0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,   // 53  S 
   0x3F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x00,   // 54  T 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,   // 55  U 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 56  V 
   0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 57  W 
   0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,   // 58  X 
   0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,   // 59  Y 
   0x7F, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x7F, 0x00,   // 5A  Z 
   0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00,   // 5B  [ 
   0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 5C  back slash
   0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00,   // 5D  ] 
   0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00,   // 5E  ^ 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 5F  _ 
   0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 60  ` 
   0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 61  a 
   0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00,   // 62  b 
   0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00,   // 63  c 
   0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00,   // 64  d 
   0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 65  e 
   0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00,   // 66  f 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 67  g 
   0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00,   // 68  h 
   0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 69  i 
   0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E,   // 6A  j 
   0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00,   // 6B  k 
   0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 6C  l 
   0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 6D  m 
   0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00,   // 6E  n 
   0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 6F  o 
   0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F,   // 70  p 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78,   // 71  q 
   0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00,   // 72  r 
   0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00,   // 73  s 
   0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00,   // 74  t 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 75  u 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 76  v 
   0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 77  w 
   0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00,   // 78  x 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 79  y 
   0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00,   // 7A  z 
   0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00,   // 7B  { 
   0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 7C  | 
   0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00,   // 7D  } 
   0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 7E  ~ 
   0x00, 0x08, 0x1C, 0x36, 0x63, 0x63, 0x7F, 0x00,   // 7F   

   0x3E, 0x63, 0x03, 0x63, 0x3E, 0x30, 0x60, 0x3E,   // 80  € 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 81   
   0x38, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 82  ‚ 
   0x7E, 0x81, 0x3C, 0x60, 0x7C, 0x66, 0xDC, 0x00,   // 83  ƒ 
   0x33, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 84  „ 
   0x07, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 85  … 
   0x0C, 0x0C, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 86  † 
   0x00, 0x00, 0x3E, 0x63, 0x03, 0x1E, 0x30, 0x1C,   // 87  ‡ 
   0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x06, 0x3C, 0x00,   // 88  ˆ 
   0x33, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 89  ‰ 
   0x07, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 8A  Š 
   0x33, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8B  ‹ 
   0x3E, 0x41, 0x1C, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 8C  Œ 
   0x07, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8D   
   0x63, 0x08, 0x3E, 0x63, 0x7F, 0x63, 0x63, 0x00,   // 8E  Ž 
   0x0C, 0x0C, 0x00, 0x1E, 0x33, 0x3F, 0x33, 0x00,   // 8F   
   0x38, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00,   // 90   
   0x00, 0x00, 0xFE, 0x30, 0xFE, 0x33, 0xFE, 0x00,   // 91  ‘ 
   0x7C, 0x36, 0x33, 0x7F, 0x33, 0x33, 0x73, 0x00,   // 92  ’ 
   0x1E, 0x21, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 93  “ 
   0x00, 0x33, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 94  ” 
   0x00, 0x07, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 95  • 
   0x1E, 0x21, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 96  – 
   0x00, 0x07, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 97  — 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 98  ˜ 
   0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 99  ™ 
   0x33, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 9A  š 
   0x18, 0x18, 0x7E, 0x03, 0x03, 0x7E, 0x18, 0x18,   // 9B  › 
   0x1C, 0x36, 0x26, 0x0F, 0x06, 0x67, 0x3F, 0x00,   // 9C  œ 
   0x33, 0x33, 0x1E, 0x0C, 0x3F, 0x0C, 0x3F, 0x0C,   // 9D   
   0x1F, 0x33, 0x33, 0x5F, 0x63, 0xF3, 0x63, 0xC3,   // 9E  ž 
   0x70, 0xD8, 0x18, 0x3C, 0x18, 0x18, 0x1B, 0x0E,   // 9F  Ÿ 
   0x38, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // A0    
   0x1C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // A1  ¡ 
   0x00, 0x38, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // A2  ¢ 
   0x00, 0x38, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // A3  £ 
   0x00, 0x1F, 0x00, 0x1D, 0x33, 0x33, 0x33, 0x00,   // A4  ¤ 
   0x3F, 0x00, 0x33, 0x37, 0x3F, 0x3B, 0x33, 0x00,   // A5  ¥ 
   0x3C, 0x36, 0x36, 0x7C, 0x00, 0x7E, 0x00, 0x00,   // A6  ¦ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x3E, 0x00, 0x00,   // A7  § 
   0x18, 0x00, 0x18, 0x18, 0x0C, 0x66, 0x3C, 0x00,   // A8  ¨ 
   0x00, 0x00, 0x00, 0x3F, 0x03, 0x03, 0x00, 0x00,   // A9  © 
   0x00, 0x00, 0x00, 0x3F, 0x30, 0x30, 0x00, 0x00,   // AA  ª 
   0x63, 0x33, 0x1B, 0x6C, 0xD6, 0x43, 0x21, 0xF0,   // AB  « 
   0xC3, 0x63, 0x33, 0xDB, 0xEC, 0xB6, 0xF3, 0xC0,   // AC  ¬ 
   0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,   // AD  ­ 
   0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,   // AE  ® 
   0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,   // AF  ¯ 
   0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11,   // B0  ° 
   0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,   // B1  ± 
   0xDB, 0x6F, 0xDB, 0xF6, 0xDB, 0x7E, 0xEB, 0xB7,   // B2  ² 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,   // B3  ³ 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B4  ´ 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B5  µ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6F, 0x6C, 0x6C, 0x6C,   // B6  ¶ 
   0x00, 0x00, 0x00, 0x00, 0x7F, 0x6C, 0x6C, 0x6C,   // B7  · 
   0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B8  ¸ 
   0x6C, 0x6C, 0x6F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // B9  ¹ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C,   // BA  º 
   0x00, 0x00, 0x7F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // BB  » 
   0x6C, 0x6C, 0x6F, 0x60, 0x7F, 0x00, 0x00, 0x00,   // BC  ¼ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x7F, 0x00, 0x00, 0x00,   // BD  ½ 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,   // BE  ¾ 
   0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18,   // BF  ¿ 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,   // C0  À 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,   // C1  Á 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,   // C2  Â 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C3  Ã 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,   // C4  Ä 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,   // C5  Å 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C6  Æ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xEC, 0x6C, 0x6C, 0x6C,   // C7  Ç 
   0x6C, 0x6C, 0xEC, 0x0C, 0xFC, 0x00, 0x00, 0x00,   // C8  È 
   0x00, 0x00, 0xFC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // C9  É 
   0x6C, 0x6C, 0xEF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CA  Ê 
   0x00, 0x00, 0xFF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CB  Ë 
   0x6C, 0x6C, 0xEC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // CC  Ì 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CD  Í 
   0x6C, 0x6C, 0xEF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CE  Î 
   0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CF  Ï 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x00, 0x00, 0x00,   // D0  Ð 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,   // D1  Ñ 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x6C, 0x6C, 0x6C,   // D2  Ò 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFC, 0x00, 0x00, 0x00,   // D3  Ó 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,   // D4  Ô 
   0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // D5  Õ 
   0x00, 0x00, 0x00, 0x00, 0xFC, 0x6C, 0x6C, 0x6C,   // D6  Ö 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x6C, 0x6C, 0x6C,   // D7  × 
   0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,   // D8  Ø 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00,   // D9  Ù 
   0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,   // DA  Ú 
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // DB  Û 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,   // DC  Ü 
   0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,   // DD  Ý 
   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,   // DE  Þ 
   0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,   // DF  ß 
   0x00, 0x00, 0x6E, 0x3B, 0x13, 0x3B, 0x6E, 0x00,   // E0  à 
   0x00, 0x1E, 0x33, 0x1F, 0x33, 0x1F, 0x03, 0x03,   // E1  á 
   0x00, 0x3F, 0x33, 0x03, 0x03, 0x03, 0x03, 0x00,   // E2  â 
   0x00, 0x00, 0x7F, 0x36, 0x36, 0x36, 0x36, 0x00,   // E3  ã 
   0x3F, 0x33, 0x06, 0x0C, 0x06, 0x33, 0x3F, 0x00,   // E4  ä 
   0x00, 0x00, 0x7E, 0x1B, 0x1B, 0x1B, 0x0E, 0x00,   // E5  å 
   0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x03,   // E6  æ 
   0x00, 0x6E, 0x3B, 0x18, 0x18, 0x18, 0x18, 0x00,   // E7  ç 
   0x3F, 0x0C, 0x1E, 0x33, 0x33, 0x1E, 0x0C, 0x3F,   // E8  è 
   0x1C, 0x36, 0x63, 0x7F, 0x63, 0x36, 0x1C, 0x00,   // E9  é 
   0x1C, 0x36, 0x63, 0x63, 0x36, 0x36, 0x77, 0x00,   // EA  ê 
   0x38, 0x0C, 0x18, 0x3E, 0x33, 0x33, 0x1E, 0x00,   // EB  ë 
   0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,   // EC  ì 
   0x60, 0x30, 0x7E, 0xDB, 0xDB, 0x7E, 0x06, 0x03,   // ED  í 
   0x1C, 0x06, 0x03, 0x1F, 0x03, 0x06, 0x1C, 0x00,   // EE  î 
   0x1E, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00,   // EF  ï 
   0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,   // F0  ð 
   0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,   // F1  ñ 
   0x06, 0x0C, 0x18, 0x0C, 0x06, 0x00, 0x3F, 0x00,   // F2  ò 
   0x18, 0x0C, 0x06, 0x0C, 0x18, 0x00, 0x3F, 0x00,   // F3  ó 
   0x70, 0xD8, 0xD8, 0x18, 0x18, 0x18, 0x18, 0x18,   // F4  ô 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x1B, 0x1B, 0x0E,   // F5  õ 
   0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,   // F6  ö 
   0x00, 0x6E, 0x3B, 0x00, 0x6E, 0x3B, 0x00, 0x00,   // F7  ÷ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,   // F8  ø 
   0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,   // F9  ù 
   0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,   // FA  ú 
   0xF0, 0x30, 0x30, 0x30, 0x37, 0x36, 0x3C, 0x38,   // FB  û 
   0x1A, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,   // FC  ü 
   0x0E, 0x19, 0x0C, 0x06, 0x1F, 0x00, 0x00, 0x00,   // FD  ý 
   0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,   // FE  þ 
   0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00    // FF  ÿ 
};


/* ----------------- LCD controller command routines ----------------- */

#ifdef INLINE_HW_ACCESS

#define WriData(ch) \
{                   \
   data_out(ch);    \
   wr_low();        \
   wr_high();       \
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00; \
}

#define WriCom(ch)  \
{                   \
   rs_low();        \
   data_out(ch);    \
   wr_low();        \
   wr_high();       \
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00; \
   rs_high();       \
}

#else

void WriData(u08 ch)
{
   data_out(ch);
   wr_low(); 
   wr_high();
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00;
}

void WriCom(u08 ch)
{
   rs_low(); 
   data_out(ch);
   wr_low(); 
   wr_high();
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00;
   rs_high();
}

#endif


void set_addr(COORD col,COORD row)
{
   if(col >= COLS) return;  /* !!!  cliping */
   else if(row >= ROWS) return;

   cs_low();

   WriCom(0x75);    // row
   WriData(row+ROW_OFS);
   WriData(MAX_COORD-1);

   WriCom(0x15);    // column
   WriData(col+COL_OFS);
   WriData(MAX_COORD-1);

   cs_high();
}


void write_screen(COORD col,COORD row, COLOR data)
{  
if(col >= COLS) return;  /* !!!  cliping */
else if(row >= ROWS) return;
   /* write screen byte that contains screen coordinate (col, row) */
   cs_low();

   WriCom(0x75);    // row
   WriData(row+ROW_OFS);
   WriData(MAX_COORD-1);

   WriCom(0x15);    // column
   WriData(col+COL_OFS);
   WriData(MAX_COORD-1);

   WriCom(0x5c);

   if(sizeof(data) > 1) {  // 16-bit color
      WriData(data>>8);   
   }

   WriData(data);

   cs_high();
}

COLOR read_screen(COORD col,COORD row)
{  /* get screen byte that contains screen coordinate (col, row) */
COLOR data;

   row += ROW_OFS;
   if(row >= MAX_COORD) return 0;
   col += COL_OFS;
   if(col >= MAX_COORD) return 0;

   cs_low();

   WriCom(0x75);    // row
   WriData(row);
   WriData(MAX_COORD-1);

   WriCom(0x15);    // column
   WriData(col);
   WriData(MAX_COORD-1);

   WriCom(0x5D);    // read data

   rd_low();        // dummy read
   rd_high();

   rd_low();
   data = DATA_PORT_READ;     
   rd_high();

   if(sizeof(data) > 1) {  // 16-bit color
      data <<= 8;

      rd_low();
      data |= DATA_PORT_READ;     
      rd_high();
   }

   cs_high();

   return data;
}

u08 read_screen_byte(unsigned addr)
{
u16 temp_top;
u08 val;

   temp_top = top_line;
   top_line = addr;

   val = read_screen(0, 0);

   top_line = temp_top;
   return val;
}

void write_screen_byte(unsigned addr, u08 val)
{
u16 temp_top;

   temp_top = top_line;
   top_line = addr;

   write_screen(0, 0, val);

   top_line = temp_top;
}



void set_lcdtop(unsigned row)
{  // set which scanline in the display buffer to start showing on the screen
u08 cur;

cur = erase_cursor();
   cs_low();

   WriCom(0xA1);      //Display start line
   WriData(row);

   WriCom(0xA2);      //Set display offset
   WriData(row);

   cs_high();
if(cur) show_cursor();
}

void lcd_xinit(u08 mode)
{
   // set control port bit outputs  DDRG bit 2,  DDRC upper 5 bits
   DDRC |= 0xF8;  
   DDRG |= 0x04; 

   cs_high();         //init the hardware control signals
   rs_high();
   wr_high();
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00;
   rd_high();

   reset_high();      //reset the panel
   delay_ms(100);
   reset_low();        
   delay_ms(100);
   reset_high();
   delay_ms(100);

   cs_low();          //start the register writing foo

   WriCom(0xAE);      //display off

   WriCom(0xCA);      //Set MUX ratio
// WriData(ROWS+ROW_OFS-1);   //1/128 duty
   WriData(MAX_COORD-1);   //1/128 duty

   WriCom(0xA1);      //Display start line
   WriData(0x00);

   WriCom(0xA2);      //Set display offset
   WriData(0x00);

   WriCom(0xA0);      //Set re-map
   if(sizeof(color) > 1) {  // 16-bit color
      WriData(0x64+2);
   }
   else {
      WriData(0x24+2);
   }

   WriCom(0xC7);      //Master current control
   WriData(0x09);

   WriCom(0xC1);      //Set contrast level for R,G,B
   WriData(0xCA);     //Red
   WriData(0x66);     //Green
   WriData(0xA6);     //Blue

   WriCom(0xB1);      //Phase adjust
   WriData(0x22);

   WriCom(0xB3);      //Set frame rate
   WriData(0x10);     //85Hz

   WriCom(0xBB);      //Set Pre-charge level for R,G,B
   WriData(0x00);     //Red
   WriData(0x00);     //Green
   WriData(0x00);     //Blue

   WriCom(0xAD);      //Master configuration
   WriData(0x8E);

   WriCom(0xB0);      //Current saving
   WriData(0x00);

   WriCom(0xBE);      //VCOMH setting
   WriData(0x1D);

   WriCom(0xA6);      //Normal display
   WriCom(0xD1);      
   WriData(0x02);

   WriCom(0xAF);      //display on

   cs_high();

   set_addr(0,0);     // cursor/drawing address
}



void dot(COORD col,COORD row)
{
u08 cur;
COLOR c;

   if(col >= COLS) return;  /* !!!  cliping */
   else if(row >= ROWS) return;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_dot(col,row);
   #endif 

cur = erase_cursor();
   if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) {  // raster op pixel to screen
      c = read_screen(col, row);
      if(draw_flags & BLIT_AND) {
         c &= color;
      }
      else if(draw_flags & BLIT_OR) {
         c |= color;
      }
      else if(draw_flags & BLIT_XOR) {
         c ^= color;
      }
   }
   else {  // copy pixel to screen
      c = color;
   }

   cs_low();

   WriCom(0x75);    // row
   WriData(row+ROW_OFS);
   WriData(MAX_COORD-1);

   WriCom(0x15);    // column
   WriData(col+COL_OFS);
   WriData(MAX_COORD-1);

   WriCom(0x5c);

   if(sizeof(c) > 1) {   // 16-bit color
      WriData(c >> 8);
   }
   WriData(c);

   cs_high();
if(cur) show_cursor();
}


void fill_screen(COLOR data)
{
unsigned i;
u08 cur;

cur = erase_cursor();
   cs_low();  

   WriCom(0x75);    // row
   WriData(0);
   WriData(MAX_COORD-1);

   WriCom(0x15);    // column
   WriData(0);
   WriData(MAX_COORD-1);

   WriCom(0x5c);

   if(sizeof(data) > 1) {  // 16-bit color
      for(i=0; i<(MAX_COORD*MAX_COORD); i++) {  
         data_out(data>>8); 
         wr_low(); 
         wr_high();
         data_out(data&0xFF);
         wr_low(); 
         wr_high();
      }
   } 
   else {
      data_out(data);
      for(i=0; i<(MAX_COORD*MAX_COORD); i++) {  
         wr_low(); 
         wr_high();
      }
   }
   DATA_PORT=0xFF; DATA_PORT_DDR=0x00;

   cs_high();
if(cur) show_cursor();
}


void lcd_char(COORD col,COORD row, unsigned char c)
{
u08 pattern;
u08 mask;
COLOR temp_color;
COORD temp_coord;
COORD b_row;
COORD b_col;
u08 cg_row;
u08 cur;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_charxy(c, col,row);
   #endif

cur = erase_cursor();

   // Chars that are color, rotated, scaled, raster op'd, or not byte aligned:
   // We draw them by building a buffer with each char row pattern expanded 
   // by *char_size*.  We then use blit() to do a memory to screen copy.
   // Only one call to blit is needed for each row of non-dithered chars.
   // Dithered chars require individual blits for each expanded sub-row 
   // of chars.
   //
   for(cg_row=0; cg_row<CHAR_HEIGHT; cg_row++) {
      if(rotate & ROT_CHAR_90) {   // generate pattern for a rotated character
         pattern = 0x00;
         for(b_col=0; b_col<CHAR_HEIGHT; b_col++) {
            b_row = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-b_col): b_col)]); /* !!! multiply */
            if(b_row & pixel_masks[(rotate & ROT_CHAR_HORIZ)?(CHAR_HEIGHT-1-cg_row): cg_row]) pattern |= pixel_masks[b_col];
         }
      }
      else {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-cg_row): cg_row)]); /* !!! multiply */
         if(rotate & ROT_CHAR_HORIZ) pattern = reverse(pattern);
      }

      // expand cgen char pattern into blit_buf (properly aligned to the
      // screen destination)
      for(b_row=0; b_row<char_size; b_row++) {  // expand cgen row vertically
         b_col = col;
         for(mask=0x01; mask; mask<<=1) {  //!!!! assumes CHAR_WIDTH==8
            for(temp_coord=0; temp_coord<char_size; temp_coord++) {  // expand cgen horizontally
               if(pattern & mask) {  // drawing a "dark" pixel
                  if(draw_flags & DITHERED) {
                     if((col+b_col)&0x01) temp_color = 1;
                     else temp_color = 0;
                     if(row & 0x01) temp_color ^= 1;
                     if(temp_color) temp_color = bg_color;
                     else temp_color = color;
                  }
                  else temp_color = color;
               }
               else temp_color = bg_color;

               blit_buf[b_col++] = temp_color;
               if(b_col >= COLS) break;
            }
         }

         if(draw_flags & DITHERED) { // must draw each dithered cgen row individually 
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,0, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += 1;
         }
         else {  // we can blit out all expanded cgen sub-rows at once
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,char_size-1, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += char_size;
            break;
         }
      }
   }

if(cur) show_cursor();
}



void blit(
   COORD left,COORD top,  
   COORD right,COORD bot,  
   COORD dest_left,COORD dest_top
)
{
COORD out_left, out_right;
COORD temp;
unsigned ofs;
INCREMENT delta;
COORD bytes;
char align;
COLOR tempc;
char row_incr;
COORD row_count;
COORD src_row;
COORD dest_row;
u08 cur;

   #ifdef MDT_CODE
      if(mdtHooked) mdt_blit(left,top,  right,bot,  dest_left,dest_top);
   #endif

   if(top > bot) {  /* normalize coordinates */
      temp = top;
      top = bot;
      bot = temp;
   }

   if(left > right) {
      temp = left;
      left = right;
      right = temp;
   }

   if(right >= COLS) right = COLS-1;   //!!! cliping

   if(dest_left >= COLS) return;   /* ignore blits off the edge */
   ofs = dest_left + (right-left);
   if(ofs >= COLS) {         /* part of blit is off the edge */
      right -= (ofs-COLS+1); /* no need to blit it, adjust blit size */
      if(right < left) return;
   }

cur = erase_cursor();
   delta = dest_left;
   ofs = delta;
   align = 0;

   row_count = bot - top + 1;
   if(dest_top > top) {  /* forward blit goes bottom to top */
      row_incr = (-1);
      src_row = bot;
      dest_row = dest_top + row_count - 1;
   }
   else {  /* backwards blit goes top to bottom */
      row_incr = 1;
      src_row = top;
      dest_row = dest_top;
   }


   while(row_count--) {  /* for each row of the blit */
      /* get source screen line into working buffer */
      bytes = 0;   
      if(draw_flags & BLIT_WRITE) {  // blit source is char buffer
         if((draw_flags & BLIT_ALIGNED) == 0) {
            temp = right+1;
            while(temp--) {
               blit_buf[delta+temp] = blit_buf[temp];
               ++bytes;
            }
         }
      }
      else if(draw_flags & (FILLED | DITHERED)) {  /* blit source is color pattern */
         if((draw_flags & BLIT_ALIGNED) == 0) {
            if(draw_flags & DITHERED) {
               if(left & 0x01) align = 1;
               else align = 0;
               if(dest_row & 1) align ^= 1;
               if(align) {
                  for(temp=left; temp<=right+0; temp+=2) {
                     blit_buf[delta+bytes] = bg_color;
                     blit_buf[delta+bytes+1] = color;
                     bytes+=2;
                  }
               }
               else {
                  for(temp=left; temp<=right+0; temp+=2) {
                     blit_buf[delta+bytes] = color;
                     blit_buf[delta+bytes+1] = bg_color;
                     bytes+=2;
                  }
               }
            }
            else {
               for(temp=left; temp<=right+0; temp++) {
                  blit_buf[delta+bytes] = color;
                  ++bytes;
               }
            }
         }
      }
      else {   /* blit source is screen memory */
if(src_row >= ROWS) goto next_row;
         cs_low();

         WriCom(0x75);    // row
         WriData(src_row+ROW_OFS);
         WriData(MAX_COORD-1);

         WriCom(0x15);    // column
         WriData(left+COL_OFS);
         WriData(MAX_COORD-1);

         WriCom(0x5D);    // read data

         rd_low();        // dummy read 
         rd_high();

         for(temp=left; temp<=right+0; temp++) {  // suck in the screen bytes
            rd_low();
            blit_buf[delta+bytes] = DATA_PORT_READ;
            rd_high();

            if(sizeof(color) > 1) {  // 16-bit color
               blit_buf[delta+bytes] <<= 8;

               rd_low();
               blit_buf[delta+bytes] |= DATA_PORT_READ;
               rd_high();
            }
            ++bytes;
         }

         cs_high();
      }

      if(draw_flags & DITHERED) set_draw_flags(draw_flags & (~BLIT_ALIGNED));
      else if(draw_flags & (BLIT_WRITE | FILLED)) set_draw_flags(draw_flags | BLIT_ALIGNED);   // only need to align source buffer once


      out_left = dest_left;
      out_right = dest_left + (right-left);

      /* head 'em up,  move 'em out */
      if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {  /* plain bit copy */
         if(draw_flags & BLIT_READ) goto next_row;
if(dest_row >= ROWS) goto next_row;
         cs_low();  

         WriCom(0x75);    // row
         WriData(dest_row+ROW_OFS);
         WriData(MAX_COORD-1);

         WriCom(0x15);    // column
         WriData(out_left+COL_OFS);
         WriData(MAX_COORD-1);

         WriCom(0x5c);

         while(out_left <= out_right) { 
            if(sizeof(color) > 1) {  // 16-bit color
               data_out(blit_buf[out_left]>>8);
               wr_low(); 
               wr_high();
               data_out(blit_buf[out_left]&0xFF);
               wr_low(); 
               wr_high();
            }
            else {
               data_out(blit_buf[out_left]);
               wr_low(); 
               wr_high();
            }
            out_left++;
         }
         DATA_PORT=0xFF; DATA_PORT_DDR=0x00;

         cs_high();
      }
      else {  /* copy with raster operation */
         while(out_left <= out_right) {
            tempc = read_screen(out_left, dest_row);
            if(draw_flags & BLIT_OR) tempc |= blit_buf[out_left];
            else if(draw_flags & BLIT_AND) tempc &= blit_buf[out_left];
            else if(draw_flags & BLIT_XOR) tempc ^= blit_buf[out_left];

            if(draw_flags & BLIT_READ) blit_buf[out_left] = tempc;
            else write_screen(out_left, dest_row, tempc);
            out_left++;
         }
      }

      next_row:
      src_row += row_incr;
      dest_row += row_incr;
   }

   set_draw_flags(draw_flags & (~BLIT_ALIGNED));
if(cur) show_cursor();
}
                        
