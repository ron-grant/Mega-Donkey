/*  MegaDonkey Library File:  LCDEL.c     EPSON LC7981 LCD DRIVER     


    Copyright 2007,2008  Mark Sims & Ron Grant


    This file is part of The Megadonkey Software Library.

    The Megadonkey Software Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Megadonkey Software Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
    more details.

    You should have received a copy of the GNU Lesser General Public License
    along with the Megadonkey Software Library. If not, see <http://www.gnu.org/licenses/>.


  

   Graphic LCD Interface Code for EPSON LC7981 based panels.
   Mark Sims  Jan 2007
 
   Low Level I/O modified for AVR + some other hacking.. - Ron Grant

   
   Panel Command Interface
   Screen Read/Write
   Character Generator (character bitmap)
   Character Drawing 
   Dot Plotting
   Blts


 This file is included in lcd.c and should not be included in IDE project, but
 instead may be added in the Other Files folder of the IDE.
 If the file is added to the IDE project you will get all kinds of errors.

 ALSO, if editing in IDE -- BE SURE to explicity save the file before 
 recompiling project -- IDE/MakeUtility will not notice if this file included 
 within LCD.C is out of date.

 This .c file does not have an associated header file.



 07 Jan 2007 - Mark's Initial creation on PC parallel port
             - Ported to AVR by Ron Grant
            

 14 JUN 2007 - added support for CrystalFontz panels with larger screens

 03 DEC 2007 - RG changed char declarations to signed char in blit due to some 
               platforms, e.g., ARM treating chars as unsigned  


*/


//@@@ #dxxx efine EXTERN extern


u08 blit_buf[(COLS/PIXELS_PER_BYTE)+2];   //!!!!!


#define reverse(x) pgm_read_byte_near(&rvs_table[x])

// LCD 8 Bit Data Bus
#define DATA_PORT       PORTA      // 8 bit bi-directional data port
#define DATA_PORT_DDR   DDRA       // Data Direction Register for Data Port

#ifdef CF   //CRYSTALFONTZ panel on AGM connector
   #define REVERSE_DB
#endif

#ifdef REVERSE_DB
   #define data_out(byte)  DATA_PORT = reverse(byte)
   #define DATA_PORT_READ  reverse(PINA)
   #define DATA_PORT_BUSY  bit_is_set(PINA,0)
#else
   #define data_out(byte)  DATA_PORT = byte
   #define DATA_PORT_READ  PINA
   #define DATA_PORT_BUSY  bit_is_set(PINA,7)
#endif


// NOP is used when compiling with optimizer on... 
// It is needed to make clock signals compatible with the LCD controller 
// chip specs.  The number of NOPs may need to be adjusted if cpu clock changes
#define NOP asm volatile ("nop")

#ifdef CF   // CRYSTALFONTZ panel on AGM connector
   #define rw_low()     cbi(PORTC,4); DATA_PORT_DDR = 0xFF
   #define rw_high()    PORTA=0xFF;   DATA_PORT_DDR=0x00; sbi(PORTC,4)
   #define cs_low()     cbi(PORTC,5); rw_low()
   #define cs_high()    sbi(PORTC,5); rw_high()
   #define cs2_low()    cbi(PORTC,6)   // cs2 is used for display on/off signal
   #define cs2_high()   sbi(PORTC,6)
   #define rs_low()     cbi(PORTC,3)
   #define rs_high()    sbi(PORTC,3)
   #define e_low()      cbi(PORTG,2)
   #define e_high()     sbi(PORTG,2); NOP; NOP; NOP;
   #define clock_e()    e_high(); e_low()
   #ifdef BIG_PANEL
      #define NX 128
      #define reset_low()  cbi(PORTC,6)
      #define reset_high() sbi(PORTC,6)
   #else
      #define NX 80
      #define reset_low()  cbi(PORTC,7)
      #define reset_high() sbi(PORTC,7)
   #endif

   u08 bus_in_use(void)
   {
      if(PINC & _BV(5)) return 0;
      else return 1;
   }
#else      // SAMSUNG LJ41-00192B panel
   #define NX 160
   #define rw_low()     cbi(PORTC,6); DATA_PORT_DDR = 0xFF 
   #define rw_high()    PORTA=0xFF;   DATA_PORT_DDR=0x00; sbi(PORTC,6) 
   #define cs_low()     cbi(PORTG,2); rw_low() 
   #define cs_high()    sbi(PORTG,2); rw_high()
   #define rs_low()     cbi(PORTC,7)           
   #define rs_high()    sbi(PORTC,7)           
   #define e_low()      cbi(PORTC,5)           
   #define e_high()     sbi(PORTC,5); NOP; NOP; NOP;
   #define clock_e()    e_high(); e_low()      
   #define reset_low()  cbi(PORTC,4)           
   #define reset_high() sbi(PORTC,4)           

   u08 bus_in_use(void)
   {
      if(PING & _BV(2)) return 0;
      else return 1;
   }
#endif


#define LCD_MODE    0x00  // LCD controller commands
#define PITCH       0x01
#define CHARS       0x02
#define DUTY        0x03
#define CPOS        0x04
#define DISP_LOW    0x08
#define DISP_HI     0x09
#define CURS_LOW    0x0A
#define CURS_HI     0x0B
#define DISP_WRT    0x0C
#define DISP_RD     0x0D
#define CLR_BIT     0x0E
#define SET_BIT     0x0F


#define TX_MODE  0x38  // LCD_MODE values
#define GR_MODE  0x32


// --------------------------------------------------------------------------------------

u08 pixel_masks[] = {
   0x01, 0x02, 0x04, 0x08,  0x10, 0x20, 0x40, 0x80
};

u08 rvs_table[] PROGMEM = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};


u08 cgen[] PROGMEM = {  // the character generator table
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 00    
   0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,   // 01    
   0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,   // 02    
   0x36, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 03    
   0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08, 0x00,   // 04    
   0x1C, 0x3E, 0x1C, 0x7F, 0x7F, 0x3E, 0x1C, 0x3E,   // 05    
   0x08, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x3E,   // 06    
   0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,   // 07    
   0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,   // 08    
   0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,   // 09    
   0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,   // 0A    
   0xF0, 0xE0, 0xF0, 0xBE, 0x33, 0x33, 0x33, 0x1E,   // 0B    
   0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,   // 0C    
   0xFC, 0xCC, 0xFC, 0x0C, 0x0C, 0x0E, 0x0F, 0x07,   // 0D    
   0xFE, 0xC6, 0xFE, 0xC6, 0xC6, 0xE6, 0x67, 0x03,   // 0E    
   0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,   // 0F    
   0x01, 0x07, 0x1F, 0x7F, 0x1F, 0x07, 0x01, 0x00,   // 10    
   0x40, 0x70, 0x7C, 0x7F, 0x7C, 0x70, 0x40, 0x00,   // 11    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,   // 12    
   0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,   // 13    
   0xFE, 0xDB, 0xDB, 0xDE, 0xD8, 0xD8, 0xD8, 0x00,   // 14    
   0x7C, 0xC6, 0x1C, 0x36, 0x36, 0x1C, 0x33, 0x1E,   // 15    
   0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,   // 16    
   0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,   // 17    
   0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,   // 18    
   0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,   // 19    
   0x00, 0x18, 0x30, 0x7F, 0x30, 0x18, 0x00, 0x00,   // 1A    
   0x00, 0x0C, 0x06, 0x7F, 0x06, 0x0C, 0x00, 0x00,   // 1B    
   0x00, 0x00, 0x03, 0x03, 0x03, 0x7F, 0x00, 0x00,   // 1C    
   0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,   // 1D    
   0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,   // 1E    
   0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,   // 1F    
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 20    
   0x0C, 0x1E, 0x1E, 0x1E, 0x0C, 0x00, 0x0C, 0x00,   // 21  ! 
   0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,   // 22  " 
   0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,   // 23  # 
   0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00,   // 24  $ 
   0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,   // 25  % 
   0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,   // 26  & 
   0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // 27  ' 
   0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,   // 28  ( 
   0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,   // 29  ) 
   0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // 2A  * 
   0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,   // 2B  + 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 2C  , 
   0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,   // 2D  - 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 2E  . 
   0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,   // 2F  / 
   0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // 30  0 
   0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,   // 31  1 
   0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,   // 32  2 
   0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,   // 33  3 
   0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,   // 34  4 
   0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,   // 35  5 
   0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,   // 36  6 
   0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,   // 37  7 
   0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 38  8 
   0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,   // 39  9 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // 3A  : 
   0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // 3B  ; 
   0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,   // 3C  < 
   0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,   // 3D  = 
   0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // 3E  > 
   0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,   // 3F  ? 
   0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,   // 40  @ 
   0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,   // 41  A 
   0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,   // 42  B 
   0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,   // 43  C 
   0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,   // 44  D 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x7E, 0x00,   // 45  E 
   0x7E, 0x06, 0x06, 0x1E, 0x06, 0x06, 0x06, 0x00,   // 46  F 
   0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,   // 47  G 
   0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,   // 48  H 
   0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 49  I 
   0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,   // 4A  J 
   0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,   // 4B  K 
   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7E, 0x00,   // 4C  L 
   0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,   // 4D  M 
   0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,   // 4E  N 
   0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,   // 4F  O 
   0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,   // 50  P 
   0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,   // 51  Q 
   0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,   // 52  R 
   0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,   // 53  S 
   0x3F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x00,   // 54  T 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,   // 55  U 
   0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 56  V 
   0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // 57  W 
   0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,   // 58  X 
   0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,   // 59  Y 
   0x7F, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x7F, 0x00,   // 5A  Z 
   0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00,   // 5B  [ 
   0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // 5C  back slash
   0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00,   // 5D  ] 
   0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00,   // 5E  ^ 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // 5F  _ 
   0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // 60  ` 
   0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 61  a 
   0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00,   // 62  b 
   0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00,   // 63  c 
   0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00,   // 64  d 
   0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 65  e 
   0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00,   // 66  f 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 67  g 
   0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00,   // 68  h 
   0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 69  i 
   0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E,   // 6A  j 
   0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00,   // 6B  k 
   0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 6C  l 
   0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // 6D  m 
   0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00,   // 6E  n 
   0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 6F  o 
   0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F,   // 70  p 
   0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78,   // 71  q 
   0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00,   // 72  r 
   0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00,   // 73  s 
   0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00,   // 74  t 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 75  u 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // 76  v 
   0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // 77  w 
   0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00,   // 78  x 
   0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 79  y 
   0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00,   // 7A  z 
   0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00,   // 7B  { 
   0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // 7C  | 
   0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00,   // 7D  } 
   0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 7E  ~ 
   0x00, 0x08, 0x1C, 0x36, 0x63, 0x63, 0x7F, 0x00,   // 7F   

   0x3E, 0x63, 0x03, 0x63, 0x3E, 0x30, 0x60, 0x3E,   // 80  Ä 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 81  Å 
   0x38, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 82  Ç 
   0x7E, 0x81, 0x3C, 0x60, 0x7C, 0x66, 0xDC, 0x00,   // 83  É 
   0x33, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 84  Ñ 
   0x07, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 85  Ö 
   0x0C, 0x0C, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // 86  Ü 
   0x00, 0x00, 0x3E, 0x63, 0x03, 0x1E, 0x30, 0x1C,   // 87  á 
   0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x06, 0x3C, 0x00,   // 88  à 
   0x33, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 89  â 
   0x07, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,   // 8A  ä 
   0x33, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8B  ã 
   0x3E, 0x41, 0x1C, 0x18, 0x18, 0x18, 0x3C, 0x00,   // 8C  å 
   0x07, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // 8D  ç 
   0x63, 0x08, 0x3E, 0x63, 0x7F, 0x63, 0x63, 0x00,   // 8E  é 
   0x0C, 0x0C, 0x00, 0x1E, 0x33, 0x3F, 0x33, 0x00,   // 8F  è 
   0x38, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00,   // 90  ê 
   0x00, 0x00, 0xFE, 0x30, 0xFE, 0x33, 0xFE, 0x00,   // 91  ë 
   0x7C, 0x36, 0x33, 0x7F, 0x33, 0x33, 0x73, 0x00,   // 92  í 
   0x1E, 0x21, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 93  ì 
   0x00, 0x33, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 94  î 
   0x00, 0x07, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // 95  ï 
   0x1E, 0x21, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 96  ñ 
   0x00, 0x07, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // 97  ó 
   0x00, 0x33, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // 98  ò 
   0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,   // 99  ô 
   0x33, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00,   // 9A  ö 
   0x18, 0x18, 0x7E, 0x03, 0x03, 0x7E, 0x18, 0x18,   // 9B  õ 
   0x1C, 0x36, 0x26, 0x0F, 0x06, 0x67, 0x3F, 0x00,   // 9C  ú 
   0x33, 0x33, 0x1E, 0x0C, 0x3F, 0x0C, 0x3F, 0x0C,   // 9D  ù 
   0x1F, 0x33, 0x33, 0x5F, 0x63, 0xF3, 0x63, 0xC3,   // 9E  û 
   0x70, 0xD8, 0x18, 0x3C, 0x18, 0x18, 0x1B, 0x0E,   // 9F  ü 
   0x38, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // A0  † 
   0x1C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // A1  ° 
   0x00, 0x38, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // A2  ¢ 
   0x00, 0x38, 0x00, 0x33, 0x33, 0x33, 0x6E, 0x00,   // A3  £ 
   0x00, 0x1F, 0x00, 0x1D, 0x33, 0x33, 0x33, 0x00,   // A4  § 
   0x3F, 0x00, 0x33, 0x37, 0x3F, 0x3B, 0x33, 0x00,   // A5  • 
   0x3C, 0x36, 0x36, 0x7C, 0x00, 0x7E, 0x00, 0x00,   // A6  ¶ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x3E, 0x00, 0x00,   // A7  ß 
   0x18, 0x00, 0x18, 0x18, 0x0C, 0x66, 0x3C, 0x00,   // A8  ® 
   0x00, 0x00, 0x00, 0x3F, 0x03, 0x03, 0x00, 0x00,   // A9  © 
   0x00, 0x00, 0x00, 0x3F, 0x30, 0x30, 0x00, 0x00,   // AA  ™ 
   0x63, 0x33, 0x1B, 0x6C, 0xD6, 0x43, 0x21, 0xF0,   // AB  ´ 
   0xC3, 0x63, 0x33, 0xDB, 0xEC, 0xB6, 0xF3, 0xC0,   // AC  ¨ 
   0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,   // AD  ≠ 
   0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,   // AE  Æ 
   0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,   // AF  Ø 
   0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11,   // B0  ∞ 
   0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,   // B1  ± 
   0xDB, 0x6F, 0xDB, 0xF6, 0xDB, 0x7E, 0xEB, 0xB7,   // B2  ≤ 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,   // B3  ≥ 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B4  ¥ 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B5  µ 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6F, 0x6C, 0x6C, 0x6C,   // B6  ∂ 
   0x00, 0x00, 0x00, 0x00, 0x7F, 0x6C, 0x6C, 0x6C,   // B7  ∑ 
   0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,   // B8  ∏ 
   0x6C, 0x6C, 0x6F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // B9  π 
   0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C,   // BA  ∫ 
   0x00, 0x00, 0x7F, 0x60, 0x6F, 0x6C, 0x6C, 0x6C,   // BB  ª 
   0x6C, 0x6C, 0x6F, 0x60, 0x7F, 0x00, 0x00, 0x00,   // BC  º 
   0x6C, 0x6C, 0x6C, 0x6C, 0x7F, 0x00, 0x00, 0x00,   // BD  Ω 
   0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,   // BE  æ 
   0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18,   // BF  ø 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,   // C0  ¿ 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,   // C1  ¡ 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,   // C2  ¬ 
   0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C3  √ 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,   // C4  ƒ 
   0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,   // C5  ≈ 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // C6  ∆ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xEC, 0x6C, 0x6C, 0x6C,   // C7  « 
   0x6C, 0x6C, 0xEC, 0x0C, 0xFC, 0x00, 0x00, 0x00,   // C8  » 
   0x00, 0x00, 0xFC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // C9  … 
   0x6C, 0x6C, 0xEF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CA    
   0x00, 0x00, 0xFF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CB  À 
   0x6C, 0x6C, 0xEC, 0x0C, 0xEC, 0x6C, 0x6C, 0x6C,   // CC  Ã 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CD  Õ 
   0x6C, 0x6C, 0xEF, 0x00, 0xEF, 0x6C, 0x6C, 0x6C,   // CE  Œ 
   0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,   // CF  œ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x00, 0x00, 0x00,   // D0  – 
   0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,   // D1  — 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0x6C, 0x6C, 0x6C,   // D2  “ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFC, 0x00, 0x00, 0x00,   // D3  ” 
   0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,   // D4  ‘ 
   0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,   // D5  ’ 
   0x00, 0x00, 0x00, 0x00, 0xFC, 0x6C, 0x6C, 0x6C,   // D6  ÷ 
   0x6C, 0x6C, 0x6C, 0x6C, 0xFF, 0x6C, 0x6C, 0x6C,   // D7  ◊ 
   0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,   // D8  ÿ 
   0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00,   // D9  Ÿ 
   0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,   // DA  ⁄ 
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // DB  € 
   0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,   // DC  ‹ 
   0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,   // DD  › 
   0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,   // DE  ﬁ 
   0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,   // DF  ﬂ 
   0x00, 0x00, 0x6E, 0x3B, 0x13, 0x3B, 0x6E, 0x00,   // E0  ‡ 
   0x00, 0x1E, 0x33, 0x1F, 0x33, 0x1F, 0x03, 0x03,   // E1  · 
   0x00, 0x3F, 0x33, 0x03, 0x03, 0x03, 0x03, 0x00,   // E2  ‚ 
   0x00, 0x00, 0x7F, 0x36, 0x36, 0x36, 0x36, 0x00,   // E3  „ 
   0x3F, 0x33, 0x06, 0x0C, 0x06, 0x33, 0x3F, 0x00,   // E4  ‰ 
   0x00, 0x00, 0x7E, 0x1B, 0x1B, 0x1B, 0x0E, 0x00,   // E5  Â 
   0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x03,   // E6  Ê 
   0x00, 0x6E, 0x3B, 0x18, 0x18, 0x18, 0x18, 0x00,   // E7  Á 
   0x3F, 0x0C, 0x1E, 0x33, 0x33, 0x1E, 0x0C, 0x3F,   // E8  Ë 
   0x1C, 0x36, 0x63, 0x7F, 0x63, 0x36, 0x1C, 0x00,   // E9  È 
   0x1C, 0x36, 0x63, 0x63, 0x36, 0x36, 0x77, 0x00,   // EA  Í 
   0x38, 0x0C, 0x18, 0x3E, 0x33, 0x33, 0x1E, 0x00,   // EB  Î 
   0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,   // EC  Ï 
   0x60, 0x30, 0x7E, 0xDB, 0xDB, 0x7E, 0x06, 0x03,   // ED  Ì 
   0x1C, 0x06, 0x03, 0x1F, 0x03, 0x06, 0x1C, 0x00,   // EE  Ó 
   0x1E, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00,   // EF  Ô 
   0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,   // F0   
   0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,   // F1  Ò 
   0x06, 0x0C, 0x18, 0x0C, 0x06, 0x00, 0x3F, 0x00,   // F2  Ú 
   0x18, 0x0C, 0x06, 0x0C, 0x18, 0x00, 0x3F, 0x00,   // F3  Û 
   0x70, 0xD8, 0xD8, 0x18, 0x18, 0x18, 0x18, 0x18,   // F4  Ù 
   0x18, 0x18, 0x18, 0x18, 0x18, 0x1B, 0x1B, 0x0E,   // F5  ı 
   0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,   // F6  ˆ 
   0x00, 0x6E, 0x3B, 0x00, 0x6E, 0x3B, 0x00, 0x00,   // F7  ˜ 
   0x1C, 0x36, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,   // F8  ¯ 
   0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,   // F9  ˘ 
   0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,   // FA  ˙ 
   0xF0, 0x30, 0x30, 0x30, 0x37, 0x36, 0x3C, 0x38,   // FB  ˚ 
   0x1A, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,   // FC  ¸ 
   0x0E, 0x19, 0x0C, 0x06, 0x1F, 0x00, 0x00, 0x00,   // FD  ˝ 
   0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,   // FE  ˛ 
   0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00    // FF  ˇ 
};


/* ----------------- LCD controller command routines ----------------- */

#ifdef INLINE_HW_ACCESS

#define busy_wait()     \
{                       \
u08 i;                  \
   e_high();            \
   i = 0;               \
   while(DATA_PORT_BUSY && (i++<50)) ;  \
   e_low();             \
}

#define cmd_wait()   \
{                    \
   rw_high();        \
   rs_high();        \
   busy_wait();      \
   rw_low();         \
   rs_low();         \
}


#define send_command(cmd, data)     \
{                                   \
   cmd_wait();                      \
   rs_high();                       \
   data_out(cmd);                   \
   clock_e();                       \
   rs_low();                        \
   data_out(data);                  \
   clock_e();                       \
}


void set_addr(col,row)       \
{                            \
unsigned addr;               \
   addr = top_line + ((((unsigned) (row) * COLS) + (unsigned) (col)) >> 3); \
   cs_low();                           \
   send_command(CURS_LOW, addr&0xFF);  \
   send_command(CURS_HI, addr>>8);     \
   cs_high();                          \
}

#else

void busy_wait(void)
{
u08 i;

   e_high();

   i = 0;
   while(DATA_PORT_BUSY && (i++<50)) ;

   e_low();
}

void cmd_wait(void)
{
   rw_high();  // read: port DDR is set to input,  pulled up
   rs_high();

   busy_wait();

   rw_low();
   rs_low();
}


void send_command(u08 cmd, u08 data)
{
   cmd_wait();        // wait for LCD not busy, leaving RW=Low

   rs_high();           // select cmd register
   data_out(cmd);
   clock_e();         // clock the cmd byte

   rs_low();            // select address data register
   data_out(data);
   clock_e();         // clock the data byte
}


void set_addr(COORD col,COORD row)
{
unsigned addr;

   addr = top_line + ((((unsigned) row * COLS) + (unsigned) col) >> 3);    /* !!! * multiply */
   cs_low();
   send_command(CURS_LOW, addr&0xFF);
   send_command(CURS_HI, addr>>8);
   cs_high();
}


#endif

void text_char(COORD col,COORD row, COLOR c)
{
unsigned addr;

   addr = top_line + ((row/CHAR_HEIGHT) * (COLS/CHAR_WIDTH)) + (col/CHAR_HEIGHT);    /* !!! * multiply */
   cs_low();
   send_command(CURS_LOW, addr&0xFF);
   send_command(CURS_HI, addr>>8);
   send_command(DISP_WRT, c);
   cs_high();
}

void write_screen(COORD col,COORD row, u08 data)
{  
unsigned addr;
   /* write screen byte that contains screen coordinate (col, row) */
   /*
      this routine is just:
      set_addr(col,row);
      send_command(DISP_WRT, data);
   */

   addr = top_line + (((((unsigned)row) * COLS) + (unsigned) col) >> 3);    /* !!! * multiply */

   cs_low();
   send_command(CURS_LOW, addr&0xFF);
   send_command(CURS_HI, addr>>8);

   cmd_wait();  /* wait for LCD not busy */

   rs_high();   /* write LCD command register */
   data_out(DISP_WRT);
   clock_e();

   rs_low();    /* write LCD data register */
   data_out(data);
   clock_e();

   cs_high();
}


u08 read_screen(COORD col,COORD row)
{  /* get screen byte that contains screen coordinate (col, row) */
u08 c;
unsigned addr;

   addr = top_line + (((((unsigned)row) * COLS) + (unsigned) col) >> 3);    /* !!! * multiply */

   cs_low();

   send_command(CURS_LOW, addr&0xFF);
   send_command(CURS_HI, addr>>8);

   cmd_wait();
   rs_high();       /* send display read command */
   data_out(DISP_RD);
   clock_e();

   rw_high();      /* put LCD port into read mode */
   busy_wait();    /* wait for display read to finish */
   rs_low();
   clock_e();      /* do the dummy read cycle */
   rs_high();
   busy_wait();    /* wait for dummy read to finish */
   rs_low();
   e_high();       /* now read the real data */
   c = DATA_PORT_READ;
   e_low();

   /* restore LCD port to pulled up, deselected read mode */
   cs_high();
   return c;
}

u08 read_screen_byte(unsigned addr)
{
u16 temp_top;
u08 val;

   temp_top = top_line;
   top_line = addr;

   val = read_screen(0, 0);

   top_line = temp_top;
   return val;
}

void write_screen_byte(unsigned addr, u08 val)
{
u16 temp_top;

   temp_top = top_line;
   top_line = addr;

   write_screen(0, 0, val);

   top_line = temp_top;
}



void set_lcdtop(unsigned row)
{  // set which scanline in the display buffer to start showing on the screen
   // for example on 160x80 display, setting to value of 80 will 
   // display 2nd page of data
u08 cur;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_set_lcdtop(row);  
   #endif    

   row *= (COLS>>3);

cur = erase_cursor();
   cs_low();

   send_command(DISP_LOW, row&0xFF);
   send_command(DISP_HI,  row>>8);

   cs_high();
if(cur) show_cursor();
}

void lcd_xinit(u08 mode)
{
   if(mode == GRAPH_MODE) mode = GR_MODE;
   else mode = TX_MODE;

   // set control port bit outputs  DDRG bit 2,  DDRC upper 5 bits
   DDRC |= 0xF8;  
   DDRG |= 0x04; 

   reset_low();         // reset the panel
   delay_ms(100);
   reset_high();

   #ifdef CF
      #ifndef BIG_PANEL
         cs2_high();    // display on
      #endif
   #endif

   e_low();
   cs_high();           // deselect LCD
   rw_low();            // Write mode
   rs_high();

   cs_low();
   send_command(LCD_MODE, mode);                // 00110010 - disp on,  master,  graphics
   send_command(PITCH, 0x77);                   // 8x8 chars
   send_command(CHARS, (COLS/CHAR_WIDTH)-1);    // 20 text chars per row

   send_command(DUTY, NX-1);                    // duty cycle
   send_command(CPOS, CHAR_HEIGHT-1);           // cursor position
   cs_high();

   set_addr(0,0);     // cursor/drawing address
}



void dot(COORD col,COORD row)
{
u08 cur;
u08 c;
u08 pixel;

   if(col >= COLS) return;  /* !!!  cliping */
   else if(row >= ROWS) return;

   #ifdef MDT_CODE
     if(mdtHooked) mdt_dot(col,row);
   #endif 

   if(text_mode) {  /* !!!! native text mode kludge */
      return text_char(col,row, color);
   }
cur = erase_cursor();
   c = read_screen(col, row);

   if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) {  // raster op pixel to screen
      pixel = c & pixel_masks[col & 0x07];
      if(draw_flags & BLIT_AND) {
         if(pixel && color) c |= pixel_masks[col & 0x07];
         else c &= (~pixel_masks[col & 0x07]);
      }
      else if(draw_flags & BLIT_OR) {
         if(pixel || color) c |= pixel_masks[col & 0x07];
         else c &= (~pixel_masks[col & 0x07]);
      }
      else if(draw_flags & BLIT_XOR) {
         if(pixel) {
            if(color == 0) c |= pixel_masks[col & 0x07];
            else c &= (~pixel_masks[col & 0x07]);
         }
         else {
            if(color) c |= pixel_masks[col & 0x07];
            else c &= (~pixel_masks[col & 0x07]);
         }
      }
   }
   else {  // copy pixel to screen
      if(color) c |= pixel_masks[col & 0x07];
      else c &= (~pixel_masks[col & 0x07]);
   }

   write_screen(col, row, c);
if(cur) show_cursor();
}


void fill_screen(COLOR data)
{
unsigned count;
u16 addr;
u08 cur;

cur = erase_cursor();

   #ifdef MDT_CODE
    if(mdtHooked) mdt_clear(data);  // color
    if(mdtNoLocalDisplay) return;
   #endif


   addr = top_line + ((((unsigned) (0) * COLS) + (unsigned) (0)) >> 3);
   cs_low();
   send_command(CURS_LOW, addr&0xFF);
   send_command(CURS_HI, addr>>8);

   cmd_wait();  /* wait for LCD not busy */

   rs_high();   /* write LCD command register */
   data_out(DISP_WRT);
   clock_e();

   rs_low();    /* access LCD data register */

   count = ROWS * (COLS>>3);
   while(count--) {   /* fast fill screen */
      cmd_wait();
      data_out(data);
      clock_e();
   }

   cs_high();

if(cur) show_cursor();
}


u08 left_mask[8] = {
   0x00, 0x01, 0x03, 0x07, 0x0F,  0x1F, 0x3F, 0x7F
};
u08 right_mask[8] = {
   0xFE, 0xFC, 0xF8, 0xF0,   0xE0, 0xC0, 0x80, 0x00
};


void lcd_char(
   COORD col,
   COORD row,
   unsigned char c
)
{
u08 pattern;
u08 mask;
COLOR temp_color;
COORD temp_coord;
COORD b_row;
COORD b_col;
u08 cg_row;
u08 cur;

   #ifdef MDT_CODE
     u08 hs = mdtHooked;
     if(mdtHooked) mdt_charxy(c, col,row);
	 mdtHooked = 0;
   #endif

   if(text_mode) {  /* !!!! native text mode kludge */
      return text_char(col,row, c);
   }

cur = erase_cursor();

   // check for special drawing cases
   if(col & 0x07) pattern = 1;  // unaligned character
   else if(char_size > 1) pattern = 2;     // char is scaled up in size
   else if(draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR | DITHERED)) pattern = 3;
   else if(rotate & ROT_CHAR_90) pattern = 4; // char is rotated 90/270 degrees
   else pattern = 0;   // a simple byte aligned char draws fastest

   if(pattern == 0) {  // simple, aligned character
      for(cg_row=0; cg_row<CHAR_HEIGHT; cg_row++) {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-cg_row): cg_row)]); /* !!! multiply */
         if(rotate & ROT_CHAR_HORIZ) pattern = reverse(pattern);
         if(bg_color >= color) {  /* !!! */
            pattern = (~pattern);
         }
         write_screen(col,row, pattern);
         ++row;
      }
if(cur) show_cursor();

      #ifdef MDT_CODE 
        mdtHooked = hs;  // restore 
      #endif 

      return;
   }

   // Chars that are rotated, scaled, raster op'd, or not byte aligned:
   // We draw them by building a buffer with each char row pattern expanded 
   // by *char_size*.  We then use blit() to do a memory to screen copy.
   // Only one call to blit is needed for each row of non-dithered big chars.
   // Dithered chars require individual blits for each expanded sub-row 
   // of big chars.
   //
   for(cg_row=0; cg_row<CHAR_HEIGHT; cg_row++) {
      if(rotate & ROT_CHAR_90) {   // generate pattern for a rotated character
         pattern = 0x00;
         for(b_col=0; b_col<CHAR_HEIGHT; b_col++) {
            b_row = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-b_col): b_col)]); /* !!! multiply */
            if(b_row & pixel_masks[(rotate & ROT_CHAR_HORIZ)?(CHAR_HEIGHT-1-cg_row): cg_row]) pattern |= pixel_masks[b_col];
         }
      }
      else {
         pattern = pgm_read_byte_near(&cgen[c*CHAR_HEIGHT + ((rotate&ROT_CHAR_VERT)?(CHAR_HEIGHT-1-cg_row): cg_row)]); /* !!! multiply */
         if(rotate & ROT_CHAR_HORIZ) pattern = reverse(pattern);
      }

      if(bg_color >= color) {  /* !!! */
         pattern = (~pattern);
      }

      // expand cgen char pattern into blit_buf (properly aligned to the
      // screen destination)
      for(b_row=0; b_row<char_size; b_row++) {  // expand cgen row vertically
         b_col = col;
         for(mask=0x01; mask; mask<<=1) {  //!!!! assumes CHAR_WIDTH==8
            for(temp_coord=0; temp_coord<char_size; temp_coord++) {  // expand cgen horizontally
               if(pattern & mask) {  // drawing a "dark" pixel
                  if(draw_flags & DITHERED) {
                     if(row & 0x01) temp_color = (~color);
                     else temp_color = color;
                     if(temp_color & pixel_masks[(col+b_col)&0x07]) temp_color = 0xFF;
                     else temp_color = 0x00;
                  }
                  else temp_color = 0xFF;
               }
               else temp_color = 0x00;

               if(temp_color) blit_buf[b_col>>3] |= pixel_masks[b_col&0x07];
               else blit_buf[b_col>>3] &= (~pixel_masks[b_col&0x07]);
               if(++b_col >= COLS) break;
            }
         }

         if(draw_flags & DITHERED) { // most draw each expanded cgen row individually 
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,0, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += 1;
         }
         else {  // we can blit out all expanded cgen sub-rows at once
            set_draw_flags(draw_flags | (BLIT_WRITE | BLIT_ALIGNED));
            blit(0,0, CHAR_WIDTH*char_size-1,char_size-1, col,row);
            set_draw_flags(draw_flags & (~(BLIT_WRITE | BLIT_ALIGNED)));
            row += char_size;
            break;
         }
      }
   }
if(cur) show_cursor();

   #ifdef MDT_CODE 
   mdtHooked = hs;  // restore 
   #endif 
}


// 12/03/2007 - RG changed char to signed char in var declarations below
//              some platforms, e.g. ARM, treat char as unsigned

void blit(
   COORD left,COORD top,  
   COORD right,COORD bot,  
   COORD dest_left,COORD dest_top
)
{
COORD out_left, out_right;
COORD temp;
unsigned ofs;
signed char delta;        // changed to signed char  and i,align,row_incr
u08 bytes;
signed char i;         
signed char align;
signed char row_incr;
COORD row_count;
COORD src_row;
COORD dest_row;
u16 addr;
u08 cur;

   #ifdef MDT_CODE
      if(mdtHooked) mdt_blit(left,top,  right,bot,  dest_left,dest_top);
   #endif

   if(top > bot) {  /* normalize coordinates */
      temp = top;
      top = bot;
      bot = temp;
   }

   if(left > right) {
      temp = left;
      left = right;
      right = temp;
   }

   if(right >= COLS) right = COLS-1;   //!!! cliping

   if(dest_left >= COLS) return;   /* ignore blits off the edge */
   ofs = dest_left + (right-left);
   if(ofs >= COLS) {         /* part of blit is off the edge */
      right -= (ofs-COLS+1); /* no need to blit it, adjust blit size */
      if(right < left) return;
   }

cur = erase_cursor();
   delta = dest_left >> 3;
   ofs = delta;
   align = (dest_left & 0x07) - (left & 0x07);

   if(align > 4) {  /* turn 5,6,7 bit shifts into a 1,2,3 bit plus a byte offset */
      align -= 8;
      ++delta;
   }
   else if(delta && (align < (-4))) {
      align += 8;
      --delta;
   }

   row_count = bot - top + 1;
   if(dest_top > top) {  /* forward blit goes bottom to top */
      row_incr = (-1);
      src_row = bot;
      dest_row = dest_top + row_count - 1;
   }
   else {  /* backwards blit goes top to bottom */
      row_incr = 1;
      src_row = top;
      dest_row = dest_top;
   }


   while(row_count--) {  /* for each row of the blit */
      /* get source screen line into working buffer */
      bytes = 0;   
      if(draw_flags & BLIT_WRITE) {  // blit source is char buffer
         if((draw_flags & BLIT_ALIGNED) == 0) {
            temp = ((right + 1) >> 3) + 1;
            while(temp--) {
               blit_buf[delta+temp] = blit_buf[temp];
               ++bytes;
            }
         }
      }
      else if(draw_flags & (FILLED | DITHERED)) {  /* blit source is color pattern */
         if((draw_flags & BLIT_ALIGNED) == 0) {
            if((draw_flags & DITHERED) && (dest_row & 1)) {
               for(temp=left; temp<=right+8; temp+=8) {
                  blit_buf[delta+bytes] = color ^ 0xFF;
                  ++bytes;
               }
            }
            else {
               for(temp=left; temp<=right+8; temp+=8) {
                  blit_buf[delta+bytes] = color;
                  ++bytes;
               }
            }
         }
      }
      else {   /* blit source is screen memory */
         addr = top_line + ((((unsigned) src_row * COLS) + (unsigned) left) >> 3);    /* !!! * multiply */
         cs_low();
         send_command(CURS_LOW, addr&0xFF);
         send_command(CURS_HI, addr>>8);

         cmd_wait();
         rs_high();       /* send display read command */
         data_out(DISP_RD);
         clock_e();

         rw_high();      /* put LCD port into read mode */
         busy_wait();    /* wait for display read command to finish */
         rs_low();
         clock_e();      /* do the dummy read cycle */

         for(temp=left; temp<=right+1; temp+=8) {  // suck in the screen bytes
            rs_high();
            busy_wait();    /* wait for read to finish */
            rs_low();
            e_high();       /* now read the real data */
            blit_buf[delta+bytes] = DATA_PORT_READ;
            e_low();

            ++bytes;
         }
         /* restore LCD port to pulled up, deselected read mode */
         cs_high();
      }

      if((draw_flags & BLIT_ALIGNED) == 0) {
         temp = align;
         if(align > 0) {  /* align source pixels to match destination bytes */
            while(temp--) {
                for(i=bytes-1; i>=0; i--) {
                   blit_buf[ofs+i] <<= 1;
                   if(blit_buf[ofs+i-1] & 0x80) blit_buf[ofs+i] |= 0x01;
                }
            }
         }
         else if(align < 0) {
            while(temp++) {
               for(i=0; i<bytes; i++) {
                  blit_buf[ofs+i] >>= 1;
                  if(blit_buf[ofs+i+1] & 0x01) blit_buf[ofs+i] |= 0x80;
               }
            }
         }
      }
      if(draw_flags & DITHERED) set_draw_flags(draw_flags & (~BLIT_ALIGNED));
      else if(draw_flags & (BLIT_WRITE | FILLED)) set_draw_flags(draw_flags | BLIT_ALIGNED);   // only need to align source buffer once



      out_left = dest_left;
      out_right = dest_left + (right-left);

      /* head 'em up,  move 'em out */
      if(((out_left & (~0x07)) == (out_right & (~0x07)))) {  /* short lines all in the same byte */
         temp = left_mask[out_left&0x07] | right_mask[out_right&0x07];
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp = (read_screen(out_left, dest_row) & temp) | (blit_buf[out_left>>3] & (~temp));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp = read_screen(out_left, dest_row) | (blit_buf[out_left>>3] & (~temp));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp = read_screen(out_left, dest_row) & (temp | (blit_buf[out_left>>3] & (~temp)));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp = read_screen(out_left, dest_row) ^ (blit_buf[out_left>>3] & (~temp));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_left>>3] = temp;
         else write_screen(out_left, dest_row, temp);
         goto next_row;
      }

      if(out_left & 0x07) {  /* unaligned pixels on the left end */
         temp = read_screen(out_left, dest_row);
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp &= left_mask[out_left&0x07];
            temp |= (blit_buf[out_left>>3] & (~left_mask[out_left & 0x07]));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp |= (blit_buf[out_left>>3] & (~left_mask[out_left & 0x07]));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp &= (left_mask[out_left & 0x07] | (blit_buf[out_left>>3] & (~left_mask[out_left & 0x07])));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp ^= (blit_buf[out_left>>3] & (~left_mask[out_left & 0x07]));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_left>>3] = temp;
         else write_screen(out_left, dest_row, temp);
         out_left += (8 - (out_left & 0x07));
      }

      if((out_right & 0x07) != 0x07) {  /* unaligned pixels on the right end */
         temp = read_screen(out_right, dest_row);
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {
            temp &= right_mask[out_right&0x07];
            temp |= (blit_buf[out_right>>3] & (~right_mask[out_right & 0x07]));
         }
         else if(draw_flags & BLIT_OR) {  /* or source to screen */
            temp |= (blit_buf[out_right>>3] & (~right_mask[out_right & 0x07]));
         }
         else if(draw_flags & BLIT_AND) {  /* and source to screen */
            temp &= (right_mask[out_right & 0x07] | (blit_buf[out_right>>3] & (~right_mask[out_right & 0x07])));
         }
         else if(draw_flags & BLIT_XOR) {  /* xor source to screen */
            temp ^= (blit_buf[out_right>>3] & (~right_mask[out_right & 0x07]));
         }

         if(draw_flags & BLIT_READ) blit_buf[out_right>>3] = temp;
         else write_screen(out_right, dest_row, temp);
         out_right -= (out_right & 0x07);
         if(out_right >= COLS) goto next_row;   //!!! cliping
      }

      if(out_left < out_right) { /* use byte writes to zap out the middle of the line */
         if((draw_flags & (BLIT_AND | BLIT_OR | BLIT_XOR)) == 0) {  /* plain bit copy */
            if(draw_flags & BLIT_READ) goto next_row;
            addr = top_line + (((((unsigned)dest_row) * COLS) + (unsigned) out_left) >> 3);    /* !!! * multiply */

            cs_low();
            send_command(CURS_LOW, addr&0xFF);
            send_command(CURS_HI, addr>>8);

            cmd_wait();  /* wait for LCD not busy */

            rs_high();   /* write LCD command register */
            data_out(DISP_WRT);
            clock_e();

            while(out_left < out_right) {
               cmd_wait();
               data_out(blit_buf[out_left>>3]);
               clock_e();
               out_left += 8;
            }
            cs_high();
         }
         else {  /* copy with raster operation */
            while(out_left < out_right) {
               temp = read_screen(out_left, dest_row);
               if(draw_flags & BLIT_OR) temp |= blit_buf[out_left>>3];
               else if(draw_flags & BLIT_AND) temp &= blit_buf[out_left>>3];
               else if(draw_flags & BLIT_XOR) temp ^= blit_buf[out_left>>3];

               if(draw_flags & BLIT_READ) blit_buf[out_left>>3] = temp;
               else write_screen(out_left, dest_row, temp);
               out_left += 8;
            }
         }
      }

      next_row:
      src_row += row_incr;
      dest_row += row_incr;
   }
   set_draw_flags(draw_flags & (~BLIT_ALIGNED));
if(cur) show_cursor();
}
                        
